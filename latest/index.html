<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>divand.jl documentation · divand</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>divand</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href="index.html">divand.jl documentation</a><ul class="internal"><li class="toplevel"><a class="toctext" href="#Examples-1">Examples</a></li><li class="toplevel"><a class="toctext" href="#Vocabulary-1">Vocabulary</a></li><li class="toplevel"><a class="toctext" href="#Information-for-developpers-1">Information for developpers</a></li><li><a class="toctext" href="#Update-the-documentation-1">Update the documentation</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href="index.html">divand.jl documentation</a></li></ul><a class="edit-page" href="https://github.com/gher-ulg/divand.jl/blob/master/docs/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>divand.jl documentation</span><a class="fa fa-bars" href="#"></a></div></header><p>divand</p><h1><a class="nav-anchor" id="divand.jl-documentation-1" href="#divand.jl-documentation-1">divand.jl documentation</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="divand.divandrun" href="#divand.divandrun"><code>divand.divandrun</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">divandrun(mask,pmn,xi,x,f,len,epsilon2; &lt;keyword arguments&gt;)</code></pre><p>Perform an n-dimensional variational analysis of the observations <code>f</code> located at the coordinates <code>x</code>. The array <code>fi</code> represent the interpolated field at the grid defined by the coordinates <code>xi</code> and the scales factors <code>pmn</code>.</p><p><strong>Input:</strong></p><ul><li><p><code>mask</code>: binary mask delimiting the domain. true is inside and false outside. For oceanographic application, this is the land-sea mask where sea is true and land is false.</p></li><li><p><code>pmn</code>: scale factor of the grid. pmn is a tuple with n elements. Every      element represents the scale factor of the corresponding dimension. Its      inverse is the local resolution of the grid in a particular dimension.</p></li><li><p><code>xi</code>: tuple with n elements. Every element represents a coordinate of the final grid on which the observations are interpolated</p></li><li><p><code>x</code>: tuple with n elements. Every element represents a coordinate of the observations</p></li><li><p><code>f</code>: value of the observations <em>minus</em> the background estimate (m-by-1 array).   (see note)</p></li><li><p><code>len</code>: correlation length</p></li><li><p><code>epsilon2</code>: error variance of the observations (normalized by the error variance of the background field). <code>epsilon2</code> can be a scalar (all observations have the same error variance and their errors are decorrelated), a vector (all observations can have a difference error variance and their errors are decorrelated) or a matrix (all observations can have a difference error variance and their errors can be correlated). If <code>epsilon2</code> is a scalar, it is thus the <em>inverse of the signal-to-noise ratio</em>.</p></li></ul><p><strong>Optional input arguments specified as keyword arguments</strong></p><ul><li><p><code>velocity</code>: velocity of advection constraint. The default is      no-advection constraint</p></li><li><p><code>alpha</code>: alpha is vector of coefficients multiplying various terms in the      cost function. The first element multiplies the norm.      The other i-th element of alpha multiplies the (i+1)-th derivative.      Per default, the highest derivative is m = ceil(1+neff/2) where neff is the      effective dimension of the problem (the number of dimensions with a nonzero      correlation length).</p><pre><code class="language-none"> The values of alpha is the (m+1)th row of the Pascal triangle:
    m=0         1
    m=1       1   1
    m=1     1   2   1     (n=1,2)
    m=2   1   3   3   1   (n=3,4)
    ...</code></pre></li><li><p><code>constraints</code>: a structure with user specified constrain</p></li><li><p><code>moddim</code>: modulo for cyclic dimension (vector with n elements).    Zero is used for non-cyclic dimensions. Halo points should    not be included for cyclic dimensions. For example if the first dimension    is cyclic, then the grid point corresponding to mask(1,j) should be    between mask(end,1) (left neighbor) and mask(2,j) (right neighbor)</p></li><li><p><code>fracindex</code>: fractional indices (n-by-m array). If this array is specified,    then x and xi are not used.</p></li><li><p><code>inversion</code>: direct solver (:chol for Cholesky factorization) or a    interative solver (:pcg for preconditioned conjugate gradient) can be    used.</p></li><li><p><code>compPC</code>: function that returns a preconditioner for the primal formulation    if inversion is set to &#39;pcg&#39;. The function has the following arguments:</p><pre><code class="language-none">     fun = compPC(iB,H,R)</code></pre><p>where iB is the inverse background error covariance, H the observation   operator and R the error covariance of the observation. The function <code>compPC</code> returns the   preconditioner <code>fun(x,fx)</code> computing fx = <code>M  x</code> (the inverse of M times x)   where <code>M</code> is a positive defined symmetric matrix [1].   Effectively, the system E⁻¹ A (E⁻¹)ᵀ (E x) = E⁻¹ b is solved for (E x) where E Eᵀ = M.   Ideally, M should this be similar to A, so that E⁻¹ A (E⁻¹)ᵀ is close to the identity matrix.</p></li><li><p><code>fi0</code>: starting field for iterative primal algorithm (same size as <code>mask</code>)</p></li><li><p><code>f0</code>: starting field for iterative dual algorithm (same size as the observations <code>f</code>)</p></li><li><p><code>operatortype</code>: Val{:sparse} for using sparse matrices (default) or Val{:MatFun} or using functions   to define the constrains.</p></li><li><p><code>scale_len</code>: true (default) if the correlation length-scale should be scaled such that the analysical   kernel reaches 0.6019072301972346 (besselk(1.,1.)) at the same distance. The kernel behaves thus similar to   the default kernel in two dimensions (alpha = [1,2,1]).</p></li><li><p><code>alphabc</code> : numerical value defining how the last grid points are stretched outward. 1, the default value mimics an infinite domain.</p></li></ul><pre><code class="language-none">To have previous behaviour of finite domain use alphabc=0</code></pre><ul><li><p><code>btrunc</code> : if provided defines where to truncate the calculation of the covariance matrix B. Only values up and including alpha[btrunc] will be calculated. IF the</p></li></ul><pre><code class="language-none">			iterative solution is calculated, the missing terms will be calculated on the fly during the conjugate gradient calulcations. Default value is none and full covariance calculation.</code></pre><p><strong>Output:</strong></p><ul><li><p><code>fi</code>: the analysed field</p></li><li><p><code>s</code>: structure with an array <code>s.P</code> representing the analysed error covariance</p></li></ul><p><strong>Note:</strong></p><p>If zero is not a valid first guess for your variable (as it is the case for   e.g. ocean temperature), you have to subtract the first guess from the   observations before calling divand and then add the first guess back in.</p><p><strong>Example:</strong></p><p>see divand_simple_example.jl</p><p><strong>References</strong></p><p>[1]  https://en.wikipedia.org/w/index.php?title=Conjugate_gradient_method&amp;oldid=761287292#The_preconditioned_conjugate_gradient_method</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/divand.jl/blob/94af132ef6efcaeb8dcab562e5663620d50e64c5/src/divandrun.jl#L1-L105">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="divand.divandgo" href="#divand.divandgo"><code>divand.divandgo</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Compute a variational analysis of arbitrarily located observations.</p><p>fi,s = divandgo(mask,pmn,xi,x,f,len,epsilon2,errormethod; ...);</p><p>Perform an n-dimensional variational analysis of the observations <code>f</code> located at the coordinates <code>x</code>. The array <code>fi</code> represent the interpolated field at the grid defined by the coordinates <code>xi</code> and the scales factors <code>pmn</code>.</p><p><strong>Input:</strong></p><p>As for divandrun but as a higher level routine which will automatically create windowing etc it also include the definition of the errormethod</p><ul><li><p>errormethod : :cpme (clever poormans method), :none or :exact</p></li></ul><p><strong>Output:</strong></p><ul><li><p><code>fi</code>: the analysed field</p></li><li><p><code>s</code>: structure with an array <code>s.P</code> representing the analysed error covariance</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/divand.jl/blob/94af132ef6efcaeb8dcab562e5663620d50e64c5/src/divandgo.jl#L1-L22">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="divand.divand_averaged_bg" href="#divand.divand_averaged_bg"><code>divand.divand_averaged_bg</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">fma,faanom = divand_averaged_bg(mask,pmn,xi,x,f,len,epsilon2,toaverage;moddim=[])</code></pre><p><strong>Input:</strong></p><p>As for divandrun, including all dimensions before averaging</p><p><strong>additional argument:</strong></p><ul><li><p>toaverage: Array of ndims of boolean telling if in the corresponding direction averaging must be done</p></li></ul><p><strong>Presently NO optional arguments from divandrun supported except moddim</strong></p><p><strong>Output:</strong></p><ul><li><p>fma: Analysis where in the directions where toaverage is true, the same value is found</p></li><li><p>faanom: Data anomalies when the analysis is subtracted from the input field.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/divand.jl/blob/94af132ef6efcaeb8dcab562e5663620d50e64c5/src/divand_averaged_bg.jl#L1-L17">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="divand.load_mask" href="#divand.load_mask"><code>divand.load_mask</code></a> — <span class="docstring-category">Function</span>.</div><div><p>deprecated</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/divand.jl/blob/94af132ef6efcaeb8dcab562e5663620d50e64c5/src/load_mask.jl#L1">source</a><div><p>deprecated</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/divand.jl/blob/94af132ef6efcaeb8dcab562e5663620d50e64c5/src/load_mask.jl#L85">source</a><div><pre><code class="language-none">xi,yi,mask = load_mask(bath_name,isglobal,xi,yi,level::Number)</code></pre><p>Generate a land-sea mask based on the topography from the NetCDF file <code>bathname</code>. The parameter <code>isglobal</code> is true if the NetCDF file covers the whole globe and  thus the last longitude point can be considered to be right next to the first longitude point. <code>xi</code> and <code>yi</code> is a vector of the longitude and latitude grid onto which the bathymetry should be  interpolated. In the water, <code>level</code> is postive and in the air <code>level</code> is negative.</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/divand.jl/blob/94af132ef6efcaeb8dcab562e5663620d50e64c5/src/load_mask.jl#L191-L201">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="divand.domain" href="#divand.domain"><code>divand.domain</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">mask,(pm,pn),(xi,yi) = domain(bathname,bathisglobal,lonr,latr)</code></pre><p>Generate a 2D geospatial domain based on the topography from the NetCDF file <code>bathname</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/divand.jl/blob/94af132ef6efcaeb8dcab562e5663620d50e64c5/src/domain.jl#L1-L6">source</a><div><pre><code class="language-none">mask,(pm,pn,po),(xi,yi,zi) = domain(bathname,bathisglobal,lonr,latr,depthr)</code></pre><p>Generate a 3D geospatial domain based on the topography from the NetCDF file <code>bathname</code>. if zlevel = :surface, then depthr is zero for the sea surface and positive in water (positive is down) if zlevel = :floor, then depthr is zero for the sea floor and positive in water (positive is up)</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/divand.jl/blob/94af132ef6efcaeb8dcab562e5663620d50e64c5/src/domain.jl#L18-L26">source</a><div><pre><code class="language-none">mask,(pm,pn,po,pp),(xi,yi,zi,ti) = domain(bathname,bathisglobal,lonr,latr,depthr,timer)</code></pre><p>Generate a geospatial domain based on the topography from the NetCDF file <code>bathname</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/divand.jl/blob/94af132ef6efcaeb8dcab562e5663620d50e64c5/src/domain.jl#L56-L61">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="divand.SDNMetadata" href="#divand.SDNMetadata"><code>divand.SDNMetadata</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">ncglobalattrib,ncvarattrib = SDNMetadata(metadata,fi)</code></pre><p>Based on the information in the dictionary <code>metadata</code> and the analysed 4D field <code>fi</code> produce a list of NetCDF global and variable attributes for <code>divand_save2</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/divand.jl/blob/94af132ef6efcaeb8dcab562e5663620d50e64c5/src/SDNMetadata.jl#L5-L10">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="divand.save" href="#divand.save"><code>divand.save</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">save(filename,xyi,fi,varname;
                      ncvarattrib = Dict(), ncglobalattrib = Dict(), ...)</code></pre><p>Save the result of the analysis in a NetCDF file .</p><p><strong>Input arguments</strong></p><ul><li><p><code>filename</code>: the name of the NetCDF file</p></li><li><p><code>xyi</code>: tuple with n vectors. Every element in this tuple represents a coordinate of the final grid on which the observations are interpolated</p></li><li><p><code>fi</code>: the analysed field</p></li><li><p><code>varname</code>: the name of the NetCDF variable</p></li></ul><p><strong>Optional arguments:</strong></p><ul><li><p><code>ncglobalattrib</code>: a dictionary with the global attributes</p></li><li><p><code>ncvarattrib</code>: a dictionary with the variable attributes</p></li><li><p><code>relerr</code>: relative error</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/divand.jl/blob/94af132ef6efcaeb8dcab562e5663620d50e64c5/src/divand_save.jl#L280-L299">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="divand.checkobs" href="#divand.checkobs"><code>divand.checkobs</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none"> checkobs(x,v,ids)
 checkobs(io::IO,x,v,ids)</code></pre><p>Print some basic information about the coordinates <code>x</code> (tuple of vector) and  values <code>v</code> (vector) having the identifier <code>ids</code> (vector of strings) to check  erroneous data. It prints wheter NaNs or Infs are found and the minimum and  maximum value.</p><p>If the argument <code>io</code> is provided, the information is input/output stream <code>io</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/divand.jl/blob/94af132ef6efcaeb8dcab562e5663620d50e64c5/src/obsstat.jl#L39-L49">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="divand.fit_isotropic" href="#divand.fit_isotropic"><code>divand.fit_isotropic</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">var0,len,distx,covar,fitcovar = fit_isotropic(x,v,distbin,min_count;
                           alpha = divand.alpha_default(length(x)),
                           len = 1.,
                           var0 = 1.,
                           minlen = 0.,
                           maxlen = 10.,
                           minvar0 = 0.,
                           maxvar0 = 10.,
                           tolrel = 1e-4,
                           maxpoints = 1000000,
                           distfun = (xi,xj) -&gt; sqrt(sum(abs2,xi-xj))),
                           progress = (var,len,fitness) -&gt; nothing
                       )</code></pre><p>Determines the optimal correlation length <code>len</code> and variance (for a separation distance approaching zero) <code>var0</code> of a cloud of data points with value <code>v</code> and coordiantes <code>x</code> (tuple of vectors with the coordinates).</p><p>The function can find the solution corresponding to  a local minimum which is not necessarily the global minimum.</p><p>See also <code>empiriccovar</code> for future information about the output parameters.</p><p>Optional input parameters:</p><ul><li><p><code>alpha</code>: if one correlation length is forced to zero during the anaylsis the values of alpha sould be set using the effective dimension. For example, if a 2D-analysis is simulated by forcing the vertical correlation length to zero, then alpha should be set to <code>[1,2,1]</code>, otherwise alpha will be <code>[1,3,3,1]</code> (for for any proper 3D analysis).</p></li><li><p><code>len</code>: initial value for the correlation length</p></li><li><p><code>var0</code>: initial value of the variance</p></li><li><p><code>minlen</code>, <code>maxlen</code>: minmum and maximum value for the correlation length</p></li><li><p><code>minvar0</code>, <code>maxvar0</code>: minmum and maximum value for the variance</p></li><li><p><code>tolrel</code>: relative tolerance for the solver</p></li><li><p><code>maxpoints</code>: maximum number of data points considered</p></li><li><p><code>distfun</code>: function to compute the distance between point <code>xi</code> (vector) and   <code>xj</code>. Per default <code>distun</code> is the Eucedian distance  <code>(xi,xj) -&gt; sqrt(sum(abs2,xi-xj)))</code>.</p></li><li><p><code>progress</code>: call-back function to show the progress of the optimization with  the input parameters <code>var</code>, <code>len</code> and <code>fitness</code> (all scalars).</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/divand.jl/blob/94af132ef6efcaeb8dcab562e5663620d50e64c5/src/fit.jl#L162-L205">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="divand.fit" href="#divand.fit"><code>divand.fit</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">var0opt,lensopt,distx,covar,fitcovar = fit(x,v,distbin,min_count;
         alpha = divand.alpha_default(length(x)),
         minlen = zeros(length(x)),
         maxlen = ones(length(x)),
         tolrel = 1e-4,
         lens0 = ones(length(x)),
         var0 = 1.,
         minvar0 = 0.,
         maxvar0 = 2.,
         maxpoints = 1000000,
         distfun = (xi,xj,lens) -&gt; sqrt(sum(abs2,(xi-xj)./lens)),
         progress = (iter,var,len,fitness) -&gt; nothing
         )</code></pre><p>The same as the function <code>fit_isotropic</code> except that now the correlation  length-scale <code>lens0</code>, <code>minlen</code>, <code>maxlen</code>, <code>lensopt</code> are a vectors  (one value per dimension). The distance function <code>distfun</code> uses an additional  parameter to compute the normalized distance.</p><p>See the note of alpha in <code>divafit</code> which also applies here.</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/divand.jl/blob/94af132ef6efcaeb8dcab562e5663620d50e64c5/src/fit.jl#L294-L315">source</a></section><h1><a class="nav-anchor" id="Examples-1" href="#Examples-1">Examples</a></h1><p>To run the example, you need to install <code>PyPlot</code>. In the folder <code>examples</code> of divand, you can run e.g. the example <code>divand_simple_example_1D.jl</code> by issuing:</p><pre><code class="language-julia"># cd(&quot;/path/to/divand/examples&quot;)
include(&quot;divand_simple_example_1D.jl&quot;)</code></pre><p>Replace <code>/path/to/divand/</code> by the installation directory of divand which is the output of <code>Pkg.dir(&quot;divand&quot;)</code> if you installed <code>divand</code> using Julias package manager.</p><h1><a class="nav-anchor" id="Vocabulary-1" href="#Vocabulary-1">Vocabulary</a></h1><p>urn_str</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="divand.Vocab.CFVocab" href="#divand.Vocab.CFVocab"><code>divand.Vocab.CFVocab</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">collection = Vocab.CFVocab(url)</code></pre><p>Create a Dict-like object represeting the NetCDF CF Standard Name vocabulary. If the <code>url</code> is not provided then current CF Standard Name list http://cfconventions.org/Data/cf-standard-names/current/src/cf-standard-name-table.xml is used. Individual standard names are retirved by indexing which return an object of the type <code>CFEntry</code>:</p><pre><code class="language-julia">collection = Vocab.CFVocab()
entry = collection[&quot;sea_water_temperature&quot;]</code></pre></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/divand.jl/blob/94af132ef6efcaeb8dcab562e5663620d50e64c5/src/Vocab.jl#L30-L44">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.haskey-Tuple{divand.Vocab.CFVocab,Any}" href="#Base.haskey-Tuple{divand.Vocab.CFVocab,Any}"><code>Base.haskey</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">bool = haskey(collection::CFVocab,stdname)</code></pre><p>Return true if <code>stdname</code> is part of the NetCDF CF Standard Name vocabulary <code>collection</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/divand.jl/blob/94af132ef6efcaeb8dcab562e5663620d50e64c5/src/Vocab.jl#L55-L60">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="divand.Vocab.SDNCollection" href="#divand.Vocab.SDNCollection"><code>divand.Vocab.SDNCollection</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">collection = SDNCollection(name)</code></pre><p>Open the SeaDataNet collection with the name <code>name</code> at the URL http://www.seadatanet.org/urnurl/collection/ The collection can be indexed with brackets using the identifier.</p><pre><code class="language-none">using divand
collection = Vocab.SDNCollection(&quot;P01&quot;)
concept = collection[&quot;PSALPR01&quot;]
@show Vocab.prefLabel(concept)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/divand.jl/blob/94af132ef6efcaeb8dcab562e5663620d50e64c5/src/Vocab.jl#L185-L198">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="divand.Vocab.prefLabel" href="#divand.Vocab.prefLabel"><code>divand.Vocab.prefLabel</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">s = Vocab.prefLabel(c::Vocab.Concept)</code></pre><p>Return the preferred label of a concept <code>c</code></p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/divand.jl/blob/94af132ef6efcaeb8dcab562e5663620d50e64c5/src/Vocab.jl#L124-L128">source</a><div><pre><code class="language-none">s = Vocab.prefLabel(urn::AbstractString)</code></pre><p>Return the preferred label of a concept usings it URN (Uniform Resource Name)</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/divand.jl/blob/94af132ef6efcaeb8dcab562e5663620d50e64c5/src/Vocab.jl#L124-L128">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="divand.Vocab.altLabel" href="#divand.Vocab.altLabel"><code>divand.Vocab.altLabel</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">s = Vocab.altLabel(c::Vocab.Concept)</code></pre><p>Return the alternative label of a concept <code>c</code></p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/divand.jl/blob/94af132ef6efcaeb8dcab562e5663620d50e64c5/src/Vocab.jl#L124-L128">source</a><div><pre><code class="language-none">s = Vocab.altLabel(urn::AbstractString)</code></pre><p>Return the alternative label of a concept usings it URN (Uniform Resource Name)</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/divand.jl/blob/94af132ef6efcaeb8dcab562e5663620d50e64c5/src/Vocab.jl#L124-L128">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="divand.Vocab.notation" href="#divand.Vocab.notation"><code>divand.Vocab.notation</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">s = Vocab.notation(c::Vocab.Concept)</code></pre><p>Return the identifier of a concept <code>c</code></p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/divand.jl/blob/94af132ef6efcaeb8dcab562e5663620d50e64c5/src/Vocab.jl#L124-L128">source</a><div><pre><code class="language-none">s = Vocab.notation(urn::AbstractString)</code></pre><p>Return the identifier of a concept usings it URN (Uniform Resource Name)</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/divand.jl/blob/94af132ef6efcaeb8dcab562e5663620d50e64c5/src/Vocab.jl#L124-L128">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.find-Tuple{divand.Vocab.Concept,Any,Any}" href="#Base.find-Tuple{divand.Vocab.Concept,Any,Any}"><code>Base.find</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">find(c::Concept,name,collection)</code></pre><p>Return a list of related concepts in the collection <code>collection</code>. <code>name</code> can be the string &quot;related&quot;, &quot;narrower&quot;, &quot;broader&quot;.</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/divand.jl/blob/94af132ef6efcaeb8dcab562e5663620d50e64c5/src/Vocab.jl#L148-L153">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="divand.Vocab.description" href="#divand.Vocab.description"><code>divand.Vocab.description</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">str = description(entry::CFEntry)
str = canonical_units(entry::CFEntry)

Return the description or the canonical units of the `entry`.</code></pre></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/divand.jl/blob/94af132ef6efcaeb8dcab562e5663620d50e64c5/src/Vocab.jl#L64-L69">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="divand.Vocab.canonical_units" href="#divand.Vocab.canonical_units"><code>divand.Vocab.canonical_units</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">str = description(entry::CFEntry)
str = canonical_units(entry::CFEntry)

Return the description or the canonical units of the `entry`.</code></pre></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/divand.jl/blob/94af132ef6efcaeb8dcab562e5663620d50e64c5/src/Vocab.jl#L64-L69">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="divand.Vocab.splitURL" href="#divand.Vocab.splitURL"><code>divand.Vocab.splitURL</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">collection,tag,key = Vocab.splitURL(url)</code></pre><p>Split a concept URL into collection, tag and key. url must finishe with a slash.</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/divand.jl/blob/94af132ef6efcaeb8dcab562e5663620d50e64c5/src/Vocab.jl#L77-L82">source</a></section><h1><a class="nav-anchor" id="Information-for-developpers-1" href="#Information-for-developpers-1">Information for developpers</a></h1><h2><a class="nav-anchor" id="Update-the-documentation-1" href="#Update-the-documentation-1">Update the documentation</a></h2><p>Install</p><pre><code class="language-julia">Pkg.add(&quot;Documenter&quot;)</code></pre><footer><hr/></footer></article></body></html>
