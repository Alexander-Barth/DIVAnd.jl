<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>divand.jl documentation · divand</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>divand</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href="index.html">divand.jl documentation</a><ul class="internal"><li class="toplevel"><a class="toctext" href="#Information-for-developpers-1">Information for developpers</a></li><li><a class="toctext" href="#Update-the-documentation-1">Update the documentation</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href="index.html">divand.jl documentation</a></li></ul><a class="edit-page" href="https://github.com/gher-ulg/divand.jl/tree/b7b460bdc8b54c56d3fe2922b6d1105b345d766b/docs/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>divand.jl documentation</span><a class="fa fa-bars" href="#"></a></div></header><p>divand</p><h1><a class="nav-anchor" id="divand.jl-documentation-1" href="#divand.jl-documentation-1">divand.jl documentation</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="divand.divandrun" href="#divand.divandrun"><code>divand.divandrun</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">divandrun(mask,pmn,xi,x,f,len,epsilon2; &lt;keyword arguments&gt;)</code></pre><p>Perform an n-dimensional variational analysis of the observations <code>f</code> located at the coordinates <code>x</code>. The array <code>fi</code> represent the interpolated field at the grid defined by the coordinates <code>xi</code> and the scales factors <code>pmn</code>.</p><p><strong>Input:</strong></p><ul><li><p><code>mask</code>: binary mask delimiting the domain. true is inside and false outside. For oceanographic application, this is the land-sea mask.</p></li><li><p><code>pmn</code>: scale factor of the grid. pmn is a tuple with n elements. Every      element represents the scale factor of the corresponding dimension. Its      inverse is the local resolution of the grid in a particular dimension.</p></li><li><p><code>xi</code>: tuple with n elements. Every element represents a coordinate of the final grid on which the observations are interpolated</p></li><li><p><code>x</code>: tuple with n elements. Every element represents a coordinate of the observations</p></li><li><p><code>f</code>: value of the observations <em>minus</em> the background estimate (m-by-1 array).   (see note)</p></li><li><p><code>len</code>: correlation length</p></li><li><p><code>epsilon2</code>: error variance of the observations (normalized by the error variance of the background field). <code>epsilon2</code> can be a scalar (all observations have the same error variance and their errors are decorrelated), a vector (all observations can have a difference error variance and their errors are decorrelated) or a matrix (all observations can have a difference error variance and their errors can be correlated). If <code>epsilon2</code> is a scalar, it is thus the <em>inverse of the signal-to-noise ratio</em>.</p></li></ul><p><strong>Optional input arguments specified as keyword arguments</strong></p><ul><li><p><code>velocity</code>: velocity of advection constraint. The default is      no-advection constraint</p></li><li><p><code>alpha</code>: alpha is vector of coefficients multiplying various terms in the      cost function. The first element multiplies the norm.      The other i-th element of alpha multiplies the (i+1)-th derivative.      Per default, the highest derivative is m = ceil(1+neff/2) where neff is the      effective dimension of the problem (the number of dimensions with a nonzero      correlation length).</p><pre><code class="language-none"> The values of alpha is the (m+1)th row of the Pascal triangle:
    m=0         1
    m=1       1   1
    m=1     1   2   1     (n=1,2)
    m=2   1   3   3   1   (n=3,4)
    ...</code></pre></li><li><p><code>EOF</code>, EOF: sub-space constraint. Orthogonal (EOF&#39; WE^2 EOF = I) (units of      EOF: m^(-n/2))</p></li><li><p><code>EOF_scaling</code>, EOF_scaling: (dimensional)</p></li><li><p><code>constraints</code>: a structure with user specified constrain</p></li><li><p><code>moddim</code>: modulo for cyclic dimension (vector with n elements).    Zero is used for non-cyclic dimensions. Halo points should    not be included for cyclic dimensions. For example if the first dimension    is cyclic, then the grid point corresponding to mask(1,j) should be    between mask(end,1) (left neighbor) and mask(2,j) (right neighbor)</p></li><li><p><code>fracindex</code>: fractional indices (n-by-m array). If this array is specified,    then x and xi are not used.</p></li><li><p><code>inversion</code>: direct solver (:chol for Cholesky factorization) or a    interative solver (:pcg for preconditioned conjugate gradient) can be    used.</p></li><li><p><code>compPC</code>: function that returns a preconditioner for the primal formulation    if inversion is set to &#39;pcg&#39;. The function has the following arguments:</p><pre><code class="language-none">     fun = compPC(iB,H,R)</code></pre><p>where iB is the inverse background error covariance, H the observation   operator and R the error covariance of the observation. The function <code>compPC</code> returns the   preconditioner <code>fun(x,fx)</code> computing fx = <code>M  x</code> (the inverse of M times x)   where <code>M</code> is a positive defined symmetric matrix [1].   Effectively, the system E⁻¹ A (E⁻¹)ᵀ (E x) = E⁻¹ b is solved for (E x) where E Eᵀ = M.   Ideally, M should this be similar to A, so that E⁻¹ A (E⁻¹)ᵀ is close to the identity matrix.</p></li><li><p><code>fi0</code>: starting field for iterative primal algorithm (same size as <code>mask</code>)</p></li><li><p><code>f0</code>: starting field for iterative dual algorithm (same size as the observations <code>f</code>)</p></li><li><p><code>operatortype</code>: Val{:sparse} for using sparse matrices (default) or Val{:MatFun} or using functions   to define the constrains.</p></li><li><p><code>scale_len</code>: true (default) if the correlation length-scale should be scaled such that the analysical   kernel reaches 0.6019072301972346 (besselk(1.,1.)) at the same distance. The kernel behaves thus similar to   the default kernel in two dimensions (alpha = [1,2,1]).</p></li><li><p><code>alphabc</code> : numerical value defining how the last grid points are stretched outward. 1, the default value mimics an infinite domain.</p></li></ul><pre><code class="language-none">To have previous behaviour of finite domain use alphabc=0</code></pre><ul><li><p><code>btrunc</code> : if provided defines where to truncate the calculation of the covariance matrix B. Only values up and including alpha[btrunc] will be calculated. IF the</p></li></ul><pre><code class="language-none">			iterative solution is calculated, the missing terms will be calculated on the fly during the conjugate gradient calulcations. Default value is none and full covariance calculation.</code></pre><p><strong>Output:</strong></p><ul><li><p><code>fi</code>: the analysed field</p></li><li><p><code>s</code>: structure with an array <code>s.P</code> representing the analysed error covariance</p></li></ul><p><strong>Note:</strong></p><p>If zero is not a valid first guess for your variable (as it is the case for   e.g. ocean temperature), you have to subtract the first guess from the   observations before calling divand and then add the first guess back in.</p><p><strong>Example:</strong></p><p>see divand_simple_example.jl</p><p><strong>References</strong></p><p>[1]  https://en.wikipedia.org/w/index.php?title=Conjugate_gradient_method&amp;oldid=761287292#The_preconditioned_conjugate_gradient_method</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/divand.jl/tree/b7b460bdc8b54c56d3fe2922b6d1105b345d766b/src/divandrun.jl#L1-L110">source</a><br/></section><h1><a class="nav-anchor" id="Information-for-developpers-1" href="#Information-for-developpers-1">Information for developpers</a></h1><h2><a class="nav-anchor" id="Update-the-documentation-1" href="#Update-the-documentation-1">Update the documentation</a></h2><p>Install</p><pre><code class="language-bash">pip3 install --user mkdocs
pip3 install --user python-markdown-math</code></pre><pre><code class="language-julia">Pkg.add(&quot;Documenter&quot;)</code></pre><footer><hr/></footer></article></body></html>
