<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>DIVAnd.jl documentation · DIVAnd</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>DIVAnd</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href="index.html">DIVAnd.jl documentation</a><ul class="internal"><li class="toplevel"><a class="toctext" href="#Bathymetry-and-spatial-temporal-domain-1">Bathymetry and spatial-temporal domain</a></li><li class="toplevel"><a class="toctext" href="#Load-observations-1">Load observations</a></li><li class="toplevel"><a class="toctext" href="#Parameter-optimization-1">Parameter optimization</a></li><li class="toplevel"><a class="toctext" href="#Vocabulary-1">Vocabulary</a></li><li class="toplevel"><a class="toctext" href="#Internal-API-or-advanced-usage-1">Internal API or advanced usage</a></li><li><a class="toctext" href="#State-vector-1">State vector</a></li><li><a class="toctext" href="#Constraints-1">Constraints</a></li><li><a class="toctext" href="#ODV-files-1">ODV files</a></li><li><a class="toctext" href="#Operators-1">Operators</a></li><li><a class="toctext" href="#Quadtree-1">Quadtree</a></li><li><a class="toctext" href="#Conjugate-gradient-1">Conjugate gradient</a></li><li><a class="toctext" href="#Utility-functions-1">Utility functions</a></li><li class="toplevel"><a class="toctext" href="#Examples-1">Examples</a></li><li class="toplevel"><a class="toctext" href="#Performance-considerations-1">Performance considerations</a></li><li><a class="toctext" href="#Tuning-the-domain-decomposition-1">Tuning the domain decomposition</a></li><li><a class="toctext" href="#Multiple-CPU-system-1">Multiple CPU system</a></li><li class="toplevel"><a class="toctext" href="#Information-for-developers-1">Information for developers</a></li><li><a class="toctext" href="#Update-the-documentation-1">Update the documentation</a></li><li class="toplevel"><a class="toctext" href="#Troubleshooting-1">Troubleshooting</a></li><li><a class="toctext" href="#No-plotting-window-appears-1">No plotting window appears</a></li><li><a class="toctext" href="#Julia-cannot-connect-to-GitHub-on-Windows-7-and-Windows-Server-2012-1">Julia cannot connect to GitHub on Windows 7 and Windows Server 2012</a></li><li><a class="toctext" href="#MbedTLS.jl-does-not-install-on-Windows-7-1">MbedTLS.jl does not install on Windows 7</a></li><li><a class="toctext" href="#EzXML.jl-cannot-be-installed-on-RedHat-6-1">EzXML.jl cannot be installed on RedHat 6</a></li><li><a class="toctext" href="#The-DIVAnd-test-suite-fails-with-automatic-download-failed-1">The DIVAnd test suite fails with <code>automatic download failed</code></a></li><li><a class="toctext" href="#METADATA-cannot-be-updated-1">METADATA cannot be updated</a></li><li><a class="toctext" href="#Convert-error-in-DIVAnd_obs-1">Convert error in <code>DIVAnd_obs</code></a></li><li><a class="toctext" href="#Monthlist-issue-1">Monthlist issue</a></li><li><a class="toctext" href="#Error-in-the-factorisation-1">Error in the factorisation</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href="index.html">DIVAnd.jl documentation</a></li></ul><a class="edit-page" href="https://github.com/gher-ulg/DIVAnd.jl/blob/master/docs/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>DIVAnd.jl documentation</span><a class="fa fa-bars" href="#"></a></div></header><p>DIVAnd</p><h1><a class="nav-anchor" id="DIVAnd.jl-documentation-1" href="#DIVAnd.jl-documentation-1">DIVAnd.jl documentation</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DIVAnd.diva3d" href="#DIVAnd.diva3d"><code>DIVAnd.diva3d</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">residuals = diva3d(xi,x,value,len,epsilon2,filename,varname)</code></pre><p>Create a 3D analysis (or a series of 3D analyses) with DIVAnd using the observations <code>value</code> (vector) at the locations <code>x</code> (tuple of vectors) onto the regular grid defined by the vectors <code>xi</code> using the scaled observational error variance  <code>epsilon2</code> and the correlation length <code>len</code>. The result will be saved in the NetCDF file <code>filename</code> under the variable <code>varname</code>.</p><p><strong>Inputs</strong></p><ul><li><p><code>xi</code>: tuple with n elements. Every element represents a coordinate of the final grid on which the observations are interpolated</p></li><li><p><code>x</code>: tuple with n elements. Every element represents a coordinate of the observations</p></li><li><p><code>value</code>: value of the observations</p></li><li><p><code>len</code>: tuple with n elements. Every element represents the correlation length.  If <code>fitcorrlen</code> is <code>true</code>, then <code>len</code> can be the empty tuple <code>()</code> or a tuple containing  3 arrays of normalized correlation lengths which will be multiplied by the  horizontal and vertical correlation lengths.</p></li><li><p><code>epsilon2</code>: error variance of the observations (normalized by the error variance of the background field). <code>epsilon2</code> can be a scalar (all observations have the same error variance and their errors are decorrelated), a vector (all observations can have a different error variance and their errors are decorrelated) or a matrix (all observations can have a different error variance and their errors can be correlated). If <code>epsilon2</code> is a scalar, it is thus the <em>inverse of the signal-to-noise ratio</em>.</p></li><li><p><code>filename</code>: The output NetCDF filename.</p></li><li><p><code>varname</code>: The name of the variable (used in the NetCDF file).</p></li></ul><p><strong>Optional input arguments:</strong></p><ul><li><p><code>bathname</code>: path to the NetCDF bathymetry (default ../../DIVAnd-example-data/Global/Bathymetry/gebco_30sec_16.nc relative to this source file)</p></li><li><p><code>bathisglobal</code>: true (default) is the bathymetry is a global data set</p></li><li><p><code>plotres</code>: Call-back routine for plotting ((timeindex,sel,fit,erri) -&gt; nothing)</p></li><li><p><code>timeorigin</code>: Time origin (default DateTime(1900,1,1,0,0,0))</p></li><li><p><code>moddim</code>: modulo for cyclic dimension (vector with n elements).    Zero is used for non-cyclic dimensions. Halo points should    not be included for cyclic dimensions. For example if the first dimension    is cyclic, then the grid point corresponding to <code>mask[1,j]</code> should be    between <code>mask[end,1]</code> (left neighbor) and <code>mask[2,j]</code> (right neighbor). The default is [0,0,0],</p></li><li><p><code>zlevel</code>: <code>:surface</code> (default) for surface analysis and <code>:floor</code> for analysis from the bottom floor.</p></li><li><p><code>ncvarattrib</code>: dictionary of NetCDF variable attributes.</p></li><li><p><code>ncglobalattrib</code>: dictionary of NetCDF global attributes.</p></li><li><p><code>transform</code>: Anamorphosis transformation function (default: <code>Anam.notransform()</code>).</p></li><li><p><code>fitcorrlen</code>: true of the correlation length is determined from the observation (default <code>false</code>).</p></li><li><p><code>fithorz_param</code>: dictionary with additional optional parameters for <code>fithorzlen</code>.</p></li><li><p><code>fitvert_param</code>: dictionary with additional optional parameters for <code>fitvertlen</code>.</p></li><li><p><code>distfun</code>: function to compute the distance (default <code>(xi,xj) -&gt; DIVAnd.distance(xi[2],xi[1],xj[2],xj[1])</code>).</p></li><li><p><code>mask</code>: if different from <code>nothing</code>, then this mask overrides land-sea mask based on the bathymetry</p></li></ul><p>(default <code>nothing</code>).</p><ul><li><p><code>background</code>: if different from <code>nothing</code>, then this parameter allows one</p></li></ul><p>to load the background from a call-back function (default <code>nothing</code>).</p><ul><li><p><code>background_espilon2_factor</code>: multiplication for <code>epsilon2</code> when computing the background (default 10.).</p></li><li><p><code>memtofit</code>: keyword controlling how to cut the domain depending on the memory   remaining available for inversion. It is not total memory (default 3).</p></li><li><p><code>niter_e</code>: Number of iterations to estimate the optimal scale factor of  <code>epsilon2</code> using Desroziers et al. 2005 (doi: 10.1256/qj.05.108). The default   is 1 (i.e. no optimization is done).</p></li></ul><p>Any additional keywoard arguments understood by <code>DIVAndgo</code> can also be used here (e.g. velocity constrain)</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/diva.jl#L1-L65">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DIVAnd.DIVAndrun" href="#DIVAnd.DIVAndrun"><code>DIVAnd.DIVAndrun</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">DIVAndrun(mask,pmn,xi,x,f,len,epsilon2; &lt;keyword arguments&gt;)</code></pre><p>Perform an n-dimensional variational analysis of the observations <code>f</code> located at the coordinates <code>x</code>. The array <code>fi</code> represent the interpolated field at the grid defined by the coordinates <code>xi</code> and the scales factors <code>pmn</code>.</p><p><strong>Input:</strong></p><ul><li><p><code>mask</code>: binary mask delimiting the domain. true is inside and false outside.</p></li></ul><p>For oceanographic application, this is the land-sea mask where sea is true and land is false.</p><ul><li><p><code>pmn</code>: scale factor of the grid. pmn is a tuple with n elements. Every  element represents the scale factor of the corresponding dimension. Its  inverse is the local resolution of the grid in a particular dimension.  For example, in two dimensions, <code>pmn</code> is a tuple <code>(pm,pn)</code> where <code>pm</code> is  the inverse of the local resolution in first dimension and <code>pn</code> is the the inverse  of the local resolution in second dimension.</p></li><li><p><code>xi</code>: tuple with n elements. Every element represents a coordinate of the final grid on which the observations are interpolated.</p></li><li><p><code>x</code>: tuple with n elements. Every element represents a coordinate of the observations.</p></li><li><p><code>f</code>: value of the observations <em>minus</em> the background estimate (vector of <code>m</code> elements where <code>m</code> is the number of observations). See also note.</p></li><li><p><code>len</code>: tuple with n elements. Every element represents the correlation length for a given dimension.</p></li><li><p><code>epsilon2</code>: error variance of the observations (normalized by the error variance of the background field). <code>epsilon2</code> can be a scalar (all observations have the same error variance and their errors are decorrelated), a vector (all observations can have a different error variance and their errors are decorrelated) or a matrix (all observations can have a different error variance and their errors can be correlated). If <code>epsilon2</code> is a scalar, it is thus the <em>inverse of the signal-to-noise ratio</em>.</p></li></ul><p><strong>Optional input arguments specified as keyword arguments</strong></p><ul><li><p><code>velocity</code>: velocity of advection constraint. The default is      no-advection constraint</p></li><li><p><code>alpha</code>: alpha is vector of coefficients multiplying various terms in the      cost function. The first element multiplies the norm.      The other i-th element of alpha multiplies the (i+1)-th derivative.      Per default, the highest derivative is m = ceil(1+neff/2) where neff is the      effective dimension of the problem (the number of dimensions with a nonzero      correlation length) and <code>ceil</code> is the ceiling function (rounding up).</p></li></ul><pre><code class="language-none">   The values of alpha is the (m+1)th row of the Pascal triangle:
      m=0         1
      m=1       1   1
      m=1     1   2   1     (n=1,2)
      m=2   1   3   3   1   (n=3,4)
      ...</code></pre><ul><li><p><code>constraints</code>: a structure with user specified constraints (see <code>DIVAnd_addc</code>).</p></li><li><p><code>moddim</code>: modulo for cyclic dimension (vector with n elements).    Zero is used for non-cyclic dimensions. One should not include a boundary    zone (sometimes called a ghost zone or halo) for cyclic dimensions.    For example if the first dimension    is cyclic, then the grid point corresponding to <code>mask[1,j]</code> should be    between <code>mask[end,1]</code> (left neighbor) and <code>mask[2,j]</code> (right neighbor).</p></li><li><p><code>fracindex</code>: fractional indices (n-by-m array). If this array is specified,    then x and xi are not used.</p></li><li><p><code>inversion</code>: direct solver (:chol for Cholesky factorization) or an    interative solver (:pcg for preconditioned conjugate gradient [1]) can be    used.</p></li><li><p><code>compPC</code>: function that returns a preconditioner for the primal formulation    if inversion is set to &#39;pcg&#39;. The function has the following arguments:</p><pre><code class="language-none">     fun = compPC(iB,H,R)</code></pre><p>where iB is the inverse background error covariance, H the observation   operator and R the error covariance of the observation. The function <code>compPC</code> returns the   preconditioner <code>fun(x,fx)</code> computing fx = <code>M \ x</code> (the inverse of M times x)   where <code>M</code> is a positive defined symmetric matrix [1].   Effectively, the system E⁻¹ A (E⁻¹)ᵀ (E x) = E⁻¹ b is solved for (E x) where E Eᵀ = M.   Ideally, M should this be similar to A, so that E⁻¹ A (E⁻¹)ᵀ is close to the identity matrix.</p></li><li><p><code>fi0</code>: starting field for iterative primal algorithm (same size as <code>mask</code>).</p></li><li><p><code>f0</code>: starting field for iterative dual algorithm (same size as the observations <code>f</code>).</p></li><li><p><code>operatortype</code>: Val{:sparse} for using sparse matrices (default) or Val{:MatFun} or using functions   to define the constrains.</p></li><li><p><code>scale_len</code>: true (default) if the correlation length-scale should be scaled   such that the analytical   kernel reaches 0.6019072301972346 (besselk(1.,1.)) at the same distance   than in 2D. The kernel behaves thus similar to   the default kernel in two dimensions (alpha = [1,2,1]).</p></li><li><p><code>alphabc</code> : numerical value defining how the last grid points are stretched outward.  If <code>alphabc</code> is 1, the default value mimics an infinite domain.  To have previous behaviour of finite domain use alphabc equal to <code>0</code>.</p></li><li><p><code>btrunc</code> : if provided defines where to truncate the calculation of the   covariance matrix B. Only values up and including alpha[btrunc] will be   calculated. If the iterative solution is calculated, the missing terms will   be calculated on the fly during the conjugate gradient calulcations. Default value is none and full covariance calculation.</p></li></ul><p><strong>Output:</strong></p><ul><li><p><code>fi</code>: the analysed field</p></li><li><p><code>s</code>: structure with an array <code>s.P</code> representing the analysed error covariance</p></li></ul><p><strong>Note:</strong></p><p>If zero is not a valid first guess for your variable (as it is the case for   e.g. ocean temperature), you have to subtract the first guess from the   observations before calling DIVAnd and then add the first guess back in.</p><p><strong>Example:</strong></p><p>see DIVAnd_simple_example.jl</p><p><strong>References</strong></p><p>[1]  https://en.wikipedia.org/w/index.php?title=Conjugate_gradient_method&amp;oldid=761287292#The_preconditioned_conjugate_gradient_method</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/DIVAndrun.jl#L1-L116">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DIVAnd.DIVAndgo" href="#DIVAnd.DIVAndgo"><code>DIVAnd.DIVAndgo</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">fi, erri, residuals, qcvalues, scalefactore = DIVAndgo(mask,pmn,xi,x,f,len,epsilon2,errormethod; ...);</code></pre><p><strong>Input:</strong></p><ul><li><p>Same arguments as DIVAndrun with in addition</p></li><li><p><code>errormethod</code> :   you have the choice between <code>:cpme</code> (clever poorman&#39;s method, default method if parameter not provided), <code>:none</code> or <code>:exact</code> (only available if windowed analysis are done with DIVAndrun)</p></li><li><p><code>MEMTOFIT=</code>: keyword controlling how to cut the domain depending on the memory remaining available for inversion (not total memory)</p></li><li><p><code>RTIMESONESCALES=</code> : if you provide a tuple of length scales, data are weighted differently depending on the numbers of neighbours they have. See <code>weight_RtimesOne</code> for details</p></li><li><p><code>QCMETHOD=</code> : if you provide a qc method parameter, quality flags are calculated. See <code>DIVAnd_cv</code> for details</p></li></ul><p><strong>Output:</strong></p><ul><li><p><code>fi</code>: the analysed field</p></li><li><p><code>erri</code>: relative error field on the same grid as fi. () if errormethod is fixed to <code>:none</code></p></li><li><p><code>residuals</code>: array of residuals at data points. For points not on the grid or on land: <code>NaN</code></p></li><li><p><code>qcvalues</code>: if <code>QCMETHOD=</code> is provided, the output array contains the quality flags otherwise qcvalues is (). For points on land or not on the grid: 0</p></li><li><p><code>scalefactore</code>: Desroziers et al. 2005 (doi: 10.1256/qj.05.108) scale factor for <code>epsilon2</code></p></li></ul><p>Perform an n-dimensional variational analysis of the observations <code>f</code> located at the coordinates <code>x</code>. The array <code>fi</code> represent the interpolated field at the grid defined by the coordinates <code>xi</code> and the scales factors <code>pmn</code>.</p><p>IMPORTANT: DIVAndgo is very similar to DIVAndrun and is only interesting to use if DIVAndrun cannot fit into memory or if you want to parallelize. (In the latter case do not forget to define the number of workers; see <code>addprocs</code> for example)</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/DIVAndgo.jl#L1-L27">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DIVAnd.DIVAnd_averaged_bg" href="#DIVAnd.DIVAnd_averaged_bg"><code>DIVAnd.DIVAnd_averaged_bg</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">fma,faanom = DIVAnd_averaged_bg(mask,pmn,xi,x,f,len,epsilon2,toaverage;moddim=[])</code></pre><p><strong>Input:</strong></p><p>As for DIVAndrun, including all dimensions before averaging</p><p><strong>additional argument:</strong></p><ul><li><p>toaverage: Array of ndims of boolean telling if in the corresponding direction averaging must be done</p></li></ul><p><strong>Presently NO optional arguments from DIVAndrun supported except moddim</strong></p><p><strong>Output:</strong></p><ul><li><p>fma: Analysis where in the directions where toaverage is true, the same value is found</p></li><li><p>faanom: Data anomalies when the analysis is subtracted from the input field.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/DIVAnd_averaged_bg.jl#L1-L17">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DIVAnd.SDNMetadata" href="#DIVAnd.SDNMetadata"><code>DIVAnd.SDNMetadata</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">ncglobalattrib,ncvarattrib = SDNMetadata(metadata,fi)</code></pre><p>Based on the information in the dictionary <code>metadata</code> and the analysed 4D field <code>fi</code> produce a list of NetCDF global and variable attributes for <code>DIVAnd_save2</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/SDNMetadata.jl#L39-L44">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DIVAnd.save" href="#DIVAnd.save"><code>DIVAnd.save</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">save(filename,xyi,fi,varname;
                      ncvarattrib = Dict(), ncglobalattrib = Dict(), ...)</code></pre><p>Save the result of the analysis in a NetCDF file .</p><p><strong>Input arguments</strong></p><ul><li><p><code>filename</code>: the name of the NetCDF file</p></li><li><p><code>xyi</code>: tuple with n vectors. Every element in this tuple represents a coordinate of the final grid on which the observations are interpolated</p></li><li><p><code>fi</code>: the analysed field</p></li><li><p><code>varname</code>: the name of the NetCDF variable</p></li></ul><p><strong>Optional arguments:</strong></p><ul><li><p><code>ncglobalattrib</code>: a dictionary with the global attributes</p></li><li><p><code>ncvarattrib</code>: a dictionary with the variable attributes</p></li><li><p><code>relerr</code>: relative error</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/DIVAnd_save.jl#L317-L336">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DIVAnd.loadbigfile" href="#DIVAnd.loadbigfile"><code>DIVAnd.loadbigfile</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">value,lon,lat,depth,time,obsid = loadbigfile(filename)</code></pre><p>Load data from the text file <code>filename</code> and returns vectors with the value, longitude, latitude, depth and time (as DateTime). A list string identifiers is also returned.</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/load_obs.jl#L1-L7">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DIVAnd.checkobs" href="#DIVAnd.checkobs"><code>DIVAnd.checkobs</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none"> checkobs(x,v,ids)
 checkobs(io::IO,x,v,ids)</code></pre><p>Print some basic information about the coordinates <code>x</code> (tuple of vector) and values <code>v</code> (vector) having the identifier <code>ids</code> (vector of strings) to check erroneous data. It prints wheter NaNs or Infs are found and the minimum and maximum value.</p><p>If the argument <code>io</code> is provided, the information is input/output stream <code>io</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/obsstat.jl#L61-L71">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DIVAnd.smoothfilter" href="#DIVAnd.smoothfilter"><code>DIVAnd.smoothfilter</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">ff = smoothfilter(x,f,scale)</code></pre><p>Smooth the function <code>f</code> defined on <code>x</code> by solving the diffusion equation</p><p>∂ₜ ϕ = ν ∂²ₓ ϕ</p><p><code>scale</code> is the spatial scales of the removed length-scales. It is defined as 2Tν  where T is the integration time.</p><p>It uses the Greens functions for 1D diffusion: 1/sqrt(4 π ν t) * exp(-x^2 / (4νt))</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/utils.jl#L377-L390">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DIVAnd.Anam.loglin" href="#DIVAnd.Anam.loglin"><code>DIVAnd.Anam.loglin</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">trans,invtrans = loglin(t; epsilon = 0.)</code></pre><p>Provide the following transform <code>log(x + epsilon)</code> (for x &lt; t) and its inverse. Beyond the threshold <code>t</code> (x ≥ t), the function is extended linearly in a  continous way.</p><p><code>trans</code>,<code>invtrans</code> are scalar functions such that for any <code>x</code> (x &gt; epsilon), <code>x == invtrans(trans(x))</code>.</p><p>For any array <code>X</code>, we have: <code>X == invtrans.(trans.(X))</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/anamorphosis.jl#L16-L27">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DIVAnd.Anam.logit" href="#DIVAnd.Anam.logit"><code>DIVAnd.Anam.logit</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">trans,invtrans = logit(; min = 0., max = 1.)</code></pre><p>Provide the logit transform and its inverse. Per default the logit transform  maps values within the interval from 0 and 1. This can be changed with the  <code>min</code> and <code>max</code> parameters. Note that trans(min) = -∞ and trans(max) = +∞.  The use safety-margin might be necessary.</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/anamorphosis.jl#L62-L69">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DIVAnd.divadoxml" href="#DIVAnd.divadoxml"><code>DIVAnd.divadoxml</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">DIVAnd.divadoxml(filepath,varname,project,cdilist,xmlfilename;
                 ignore_errors = false)</code></pre><p>Generate the XML metadata file <code>xmlfilename</code> from the NetCDF file <code>filepath</code> with the  NetCDF variable <code>varname</code>. Project is either &quot;SeaDataNet&quot;, &quot;EMODNET-chemistry&quot; or &quot;SeaDataCloud&quot;. <code>cdilist</code> is the file from http://emodnet-chemistry.maris2.nl/download/export.zip.</p><p>The XML file contain a list of the data the originators. divadoxml will abort with an error if some combinations of EDMO code, local CDI ID are not present in the <code>cdilist</code>. Such errors can be ignore if <code>ignore_errors</code> is set to true.</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/SDNMetadata.jl#L601-L614">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DIVAnd.random" href="#DIVAnd.random"><code>DIVAnd.random</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">field = DIVAnd.random(mask,pmn,len,Nens)</code></pre><p>Create <code>Nens</code> random fields with the correlation length <code>len</code> in  a domain with the mask <code>mask</code> and the metric <code>pmn</code>.</p><p>See <code>DIVAnd.DIVAndrun</code> for more information about these parameters.</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/utils.jl#L398-L405">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DIVAnd.distance" href="#DIVAnd.distance"><code>DIVAnd.distance</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">d = distance(lat1,lon1,lat2,lon2)</code></pre><p>Compute the great-circle distance between the points (<code>lat1,</code>lon1<code>) and (</code>lat2,<code>lon2</code>). The units of all input and output parameters are degrees.</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/DIVAnd_metric.jl#L2-L7">source</a><div><pre><code class="language-none">d = distance([lon1,lat1],[lon2,lat2])</code></pre><p>The same as <code>distance(lat1,lon1,lat2,lon2)</code> but there the arguments are vectors  and the order is longitude then latitude.</p><p>The units of all input and output parameters are degrees.</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/DIVAnd_metric.jl#L22-L29">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DIVAnd.interp" href="#DIVAnd.interp"><code>DIVAnd.interp</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">f = interp(xi,fi,x)</code></pre><p>Interpolate field <code>fi</code> (n-dimensional array) defined at <code>xi</code> (tuble of n-dimensional arrays or vectors) onto grid <code>x</code> (tuble of n-dimensional arrays). The grid in <code>xi</code> must be align with the axis (e.g. produced by DIVAnd.ndgrid).</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/utils.jl#L469-L475">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DIVAnd.backgroundfile" href="#DIVAnd.backgroundfile"><code>DIVAnd.backgroundfile</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">fun = backgroundfile(fname,varname)</code></pre><p>Return a function <code>fun</code> which is used in DIVAnd to make  anomalies out of observations based relative to the field defined in the NetCDF variable <code>varname</code> in the NetCDF file  <code>fname</code>. It is assumed that the NetCDF variables has the variable <code>lon</code>, <code>lat</code> and <code>depth</code>. And that the NetCDF variable is defined on the  same grid as the analysis.</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/utils.jl#L485-L495">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DIVAnd.Quadtrees.checkduplicates" href="#DIVAnd.Quadtrees.checkduplicates"><code>DIVAnd.Quadtrees.checkduplicates</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">dupl = checkduplicates(x,value,delta,deltavalue)</code></pre><p>Based the coordinates <code>x</code> (a tuple of longitude <code>lons</code>, latitudes <code>lats</code>, depth (<code>zs</code>) and time (<code>times</code> vector of <code>DateTime</code>)) check of points who are in the same spatio-temporal bounding  box of a length <code>delta</code>. <code>delta</code> is a vector with 4 elements corresponding to longitude, latitude, depth and time (in days). <code>dupl</code> a vector of vectors containing indices of the duplicates.</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/Quadtrees.jl#L435-L443">source</a><div><pre><code class="language-none">dupl = checkduplicates(x1,value1,x2,v2,value2,delta,deltavalue)</code></pre><p>Report duplicate of observation in data set (x2,v2) which are also in data set (x1,v1). <code>x1</code> and <code>x2</code> is a tuple of vectors with the cooridantes and <code>v1</code> and <code>v2</code> the corresponding values.</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/Quadtrees.jl#L512-L518">source</a></section><h1><a class="nav-anchor" id="Bathymetry-and-spatial-temporal-domain-1" href="#Bathymetry-and-spatial-temporal-domain-1">Bathymetry and spatial-temporal domain</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DIVAnd.load_bath" href="#DIVAnd.load_bath"><code>DIVAnd.load_bath</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">xi,yi,bath = DIVAnd.load_bath(bath_name,isglobal,xi,yi)</code></pre><p>Load the bathymetry from the NetCDF file <code>bathname</code>. The parameter <code>isglobal</code> is true if the NetCDF file covers the whole globe and thus the last longitude point can be considered to be right next to the first longitude point. <code>xi</code> and <code>yi</code> are vectors containing the longitude and latitude grid onto which the bathymetry should be interpolated.</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/load_mask.jl#L64-L72">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DIVAnd.extract_bath" href="#DIVAnd.extract_bath"><code>DIVAnd.extract_bath</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">bx,by,b = DIVAnd.extract_bath(bath_name,isglobal,xi,yi)</code></pre><p>Extract the bathymetry from the NetCDF file <code>bathname</code>. The parameter <code>isglobal</code>  is true if the NetCDF file covers the whole globe and thus the last longitude point can be considered to be right next to the first longitude point. <code>xi</code> and <code>yi</code> are vectors defining the bounding box of the data. No interpolation is performed.</p><p><strong>Convention:</strong> b is positive in the water and negative in the air.</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/load_mask.jl#L2-L12">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DIVAnd.load_mask" href="#DIVAnd.load_mask"><code>DIVAnd.load_mask</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">xi,yi,mask = load_mask(bath_name,isglobal,xi,yi,level::Number)</code></pre><p>Generate a land-sea mask based on the topography from the NetCDF file <code>bathname</code>. The parameter <code>isglobal</code> is true if the NetCDF file covers the whole globe and thus the last longitude point can be considered to be right next to the first longitude point. <code>xi</code> and <code>yi</code> are vectors containing the longitude and latitude grid onto which the bathymetry should be interpolated.</p><p><strong>Convention:</strong> in the water, <code>level</code> is positive and in the air <code>level</code> is negative.</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/load_mask.jl#L107-L118">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DIVAnd.DIVAnd_metric" href="#DIVAnd.DIVAnd_metric"><code>DIVAnd.DIVAnd_metric</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">pm,pn = DIVAnd_metric(lon,lat)</code></pre><p>Compute metric scale factors <code>pm</code> and <code>pn</code> based on the arrays longitude <code>lon</code> and latitude <code>lat</code>. The variables pm and pn represent the inverse of the local resolution in meters using the mean Earth radius.</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/DIVAnd_metric.jl#L34-L41">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DIVAnd.domain" href="#DIVAnd.domain"><code>DIVAnd.domain</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">mask,(pm,pn),(xi,yi) = domain(bathname,bathisglobal,lonr,latr)</code></pre><p>Generate a 2D geospatial domain based on the topography from the NetCDF file <code>bathname</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/domain.jl#L69-L74">source</a><div><pre><code class="language-none">mask,(pm,pn,po),(xi,yi,zi) = domain(bathname,bathisglobal,lonr,latr,depthr)</code></pre><p>Generate a 3D geospatial domain based on the topography from the NetCDF file <code>bathname</code>. If <code>zlevel</code> is <code>:surface</code>, then <code>depthr</code> is zero for the sea surface and  positive in water (positive is down). If <code>zlevel</code> is <code>:floor</code>, then <code>depthr</code> is  zero for the sea floor and positive in water (positive is up)</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/domain.jl#L85-L92">source</a><div><pre><code class="language-none">mask,(pm,pn,po,pp),(xi,yi,zi,ti) = domain(bathname,bathisglobal,lonr,latr,depthr,timer)</code></pre><p>Generate a geospatial domain based on the topography from the NetCDF file <code>bathname</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/domain.jl#L120-L125">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DIVAnd.DIVAnd_rectdom" href="#DIVAnd.DIVAnd_rectdom"><code>DIVAnd.DIVAnd_rectdom</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">mask,pmn,xyi = DIVAnd_rectdom(coord1,coord2,...)</code></pre><p>Create a &quot;rectangular&quot; domain in <code>n</code> dimensions with the coordinates <code>coord1</code> <code>coord2</code>... assuming a Catersian metric. This functions returns the mask <code>mask</code>, the coordinates <code>(xi,yi,...)</code> and the metric <code>(pm,pn...)</code>.</p><p>For example:</p><pre><code class="language-julia-repl">julia&gt; mask,(pm,pn),(xi,yi) = DIVAnd_rectdom(linspace(0,1,50),linspace(0,1,50))</code></pre></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/domain.jl#L41-L53">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DIVAnd.DIVAnd_squaredom" href="#DIVAnd.DIVAnd_squaredom"><code>DIVAnd.DIVAnd_squaredom</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">mask,pmn,xyi = DIVAnd_squaredom(n,coord)</code></pre><p>Create a &quot;square&quot; domain in <code>n</code> dimensions with the coordinates <code>coord</code> assuming a Catersian metric. This functions returns the mask <code>mask</code>, the coordinates <code>(xi,yi,...)</code> and the metric <code>(pm,pn...)</code>.</p><p><strong>Example</strong></p><p>mask,(pm,pn),(xi,yi) = DIVAnd_squaredom(2,linspace(0,1,50))</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/domain.jl#L24-L34">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DIVAnd.TimeSelectorYW" href="#DIVAnd.TimeSelectorYW"><code>DIVAnd.TimeSelectorYW</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">TS = TimeSelectorYW(years,yearwindow,monthlists)</code></pre><p>The structure <code>TS</code> handles the time aggregation based on <code>years</code> and <code>monthlists</code>. It is similar to <code>TimeSelectorYearListMonthList</code> except that the elements of <code>yearlists</code> are centred around <code>years</code> and span <code>yearwindow</code> years. <code>yearlists</code> is in fact constructed by adding and subtracting <code>yearwindow/2</code> to every element of years.</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/select_time.jl#L167-L176">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DIVAnd.TimeSelectorYearListMonthList" href="#DIVAnd.TimeSelectorYearListMonthList"><code>DIVAnd.TimeSelectorYearListMonthList</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">TS = TimeSelectorYearListMonthList(yearlists,monthlists)</code></pre><p>The structure <code>TS</code> handles the time aggregation based on <code>yearlists</code> and <code>monthlists</code>. <code>yearlists</code> is a vector of ranges (containing start and end years), for example <code>[1980:1990,1990:2000,2000:2010]</code>.</p><p><code>monthlists</code> is a vector of two-element vector (containing start and end months), for example <code>[1:3,4:6,7:9,10:12]</code></p><p>If a month range spans beyond December, then all Months must be specified, e.g. example <code>[2:4,5:6,7:9,[10,11,12,1]]</code> or <code>[2:4,5:6,7:9,[10:12;1]]</code>. However using <code>[2:4,5:6,7:9,10:1]</code> (bug!) will result in an empty month range.</p><p><strong>Example</strong></p><p><strong>seasonal climatology using all data from 1900 to 2017</strong></p><p><strong>for winter (December-February), spring, summer, autumn</strong></p><p>TS = DIVAnd.TimeSelectorYearListMonthList([1900:2017],[[12,1,2],[3,4,5],[6,7,8],[9,10,11]])</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/select_time.jl#L9-L31">source</a></section><h1><a class="nav-anchor" id="Load-observations-1" href="#Load-observations-1">Load observations</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DIVAnd.saveobs" href="#DIVAnd.saveobs"><code>DIVAnd.saveobs</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">DIVAnd.saveobs(filename,xy,ids;
               type_save = Float32,
               timeorigin = DateTime(1900,1,1,0,0,0),
               )</code></pre><p>Save the location and time of the observation in the NetCDF file <code>filename</code> and their identifier <code>ids</code>. <code>xy</code> is a tuple with the vectors longitude, latitude, depth and time (as a vector of <code>DateTime</code>).</p><p><strong>Optional arguments:</strong></p><ul><li><p><code>type_save</code>: the type to save the data (default Float32). However, the time  is always saved as <code>Float64</code>.</p></li><li><p><code>timeorigin</code>: time origin for the time units attribute (default is</p></li></ul><p>1900-01-01 00:00:00)</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/DIVAnd_save.jl#L356-L371">source</a><div><pre><code class="language-none">DIVAnd.saveobs(filename,varname,value,xy,ids;
               type_save = Float32,
               timeorigin = DateTime(1900,1,1,0,0,0),
               )</code></pre><p>Save <code>value</code> and the location and time of the observation in the NetCDF file <code>filename</code> and their identifier <code>ids</code>. <code>xy</code> is a tuple with the vectors longitude, latitude, depth and time (as a vector of <code>DateTime</code>). The values will be saved in the  variable called <code>varname</code>.</p><p><strong>Optional arguments:</strong></p><ul><li><p><code>type_save</code>: the type to save the data (default Float32). However, the time  is always saved as <code>Float64</code>.</p></li><li><p><code>timeorigin</code>: time origin for the time units attribute (default is</p></li></ul><p>1900-01-01 00:00:00)</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/DIVAnd_save.jl#L431-L448">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DIVAnd.loadobs" href="#DIVAnd.loadobs"><code>DIVAnd.loadobs</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">obsvalue,obslon,obslat,obsdepth,obstime,obsid = loadobs(T,filename,varname)</code></pre><p>Load the variable <code>varname</code> from the NetCDF file <code>filename</code>. Coordinates (the NetCDF variables &quot;obslon&quot;, &quot;obslat&quot;, &quot;obsdepth&quot;), time (&quot;obstime&quot;) and identifies (&quot;obsids&quot;) will also be loaded. Numeric output arguments will have the type <code>T</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/load_obs.jl#L73-L81">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DIVAnd.NCSDN.load" href="#DIVAnd.NCSDN.load"><code>DIVAnd.NCSDN.load</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">data,lon,lat,z,time,ids = load(T,fname::TS,param; qualityflags = [GOOD_VALUE, PROBABLY_GOOD_VALUE]) where TS &lt;: AbstractString</code></pre></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/NCSDN.jl#L78-L82">source</a><div><pre><code class="language-none">data,lon,lat,z,time,ids = SDN.load(T,fnames,param; qualityflags = ...)</code></pre><p>Load all data in the vector of file names <code>fnames</code> corresponding to the parameter  <code>param</code> as the data type <code>T</code>. Only the data with the quality flags  <code>SDN.good_data</code> and <code>SDN.probably_good_data</code> are loaded per default. The output parameters correspondata to the data, longitude, latitude, depth, time (as <code>DateTime</code>) and an identifier (as <code>String</code>).</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/NCSDN.jl#L157-L165">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DIVAnd.NCSDN.loadvar" href="#DIVAnd.NCSDN.loadvar"><code>DIVAnd.NCSDN.loadvar</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">data = loadvar(ds,param;
               fillvalue::T = NaN,
               qualityflags = [GOOD_VALUE, PROBABLY_GOOD_VALUE],
               qfname = param * QC_SUFFIX,
               )</code></pre><p>Load the NetCDF variable <code>param</code> from the NCDataset <code>ds</code>.  Data points not having the provide quality flags will be masked by <code>fillvalue</code>. <code>qfname</code> is the NetCDF variable name for the quality flags.</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/NCSDN.jl#L37-L48">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DIVAnd.ODVspreadsheet.loaddata" href="#DIVAnd.ODVspreadsheet.loaddata"><code>DIVAnd.ODVspreadsheet.loaddata</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">data = loaddata(sheet,profile,locname,fillvalue; fillmode = :repeat)</code></pre><p>Load a single column referred by the local name <code>locname</code> in the profile <code>profile</code> from the ODV spreadsheet <code>sheet</code>. Empty values are either replaced by <code>fillvalue</code> (if fillmode is :fill) or the previous value if repeated (if fillmode is :repeat)</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/ODVspreadsheet.jl#L370-L377">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DIVAnd.ODVspreadsheet.parsejd" href="#DIVAnd.ODVspreadsheet.parsejd"><code>DIVAnd.ODVspreadsheet.parsejd</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">dt = parsejd(t)</code></pre><p>Convert a Chronological Julian Day Number to a DateTime object. The reference value is taken from <a href="https://web.archive.org/web/20171129142108/https://www.hermetic.ch/cal_stud/chron_jdate.htm">Chronological Julian Date</a></p><p>From the SDN standard: &quot;A real number representing the Chronological Julian Date, which is defined as the time elapsed in days from 00:00 on January 1 st 4713 BC. ... &quot;</p><p>The time origin is _not_ noon (12:00) on Monday, January 1, 4713 BC as for the Julia Date Number.</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/ODVspreadsheet.jl#L299-L311">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DIVAnd.ODVspreadsheet.myparse" href="#DIVAnd.ODVspreadsheet.myparse"><code>DIVAnd.ODVspreadsheet.myparse</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">v = myparse(T,s)</code></pre><p>Parse the string <code>s</code> as a type <code>T</code>. Unlike Julia&#39;s parse function an error message contains the string <code>s</code> (which could not be parsed) for debugging.</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/ODVspreadsheet.jl#L315-L321">source</a></section><h1><a class="nav-anchor" id="Parameter-optimization-1" href="#Parameter-optimization-1">Parameter optimization</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DIVAnd.fit_isotropic" href="#DIVAnd.fit_isotropic"><code>DIVAnd.fit_isotropic</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">var0,len,distx,covar,fitcovar = fit_isotropic(x,v,distbin,mincount;
                           alpha = DIVAnd.alpha_default(length(x)),
                           minlen = 0.,
                           maxlen = 10.,
                           tolrel = 1e-4,
                           maxpoints = 10000,
                           nmean = 100,
                           distfun = (xi,xj) -&gt; sqrt(sum(abs2,xi-xj))),
                           progress = (iter,var,len,fitness) -&gt; nothing
                       )</code></pre><p>Determines the optimal correlation length <code>len</code> and variance (for a separation distance approaching zero) <code>var0</code> of a cloud of data points with value <code>v</code> and coordiantes <code>x</code> (tuple of vectors with the coordinates).</p><p>The function can find the solution corresponding to a local minimum which is not necessarily the global minimum.</p><p>See also <code>empiriccovar</code> for future information about the output parameters.</p><p>Optional input parameters:</p><ul><li><p><code>alpha</code>: if one correlation length is forced to zero during the anaylsis the values of alpha sould be set using the effective dimension. For example, if a 2D-analysis is simulated by forcing the vertical correlation length to zero, then alpha should be set to <code>[1,2,1]</code>, otherwise alpha will be <code>[1,3,3,1]</code> (for any proper 3D analysis).</p></li><li><p><code>len</code>: initial value for the correlation length.</p></li><li><p><code>minlen</code>, <code>maxlen</code>: minimum and maximum values for the correlation length.</p></li><li><p><code>tolrel</code>: relative tolerance for the optimizer.</p></li><li><p><code>maxpoints</code>: maximum number of data points considered.</p></li><li><p><code>nmean</code>: the number of times an empirical covariance is estimated.  The average covariance is used for the fitting.</p></li><li><p><code>distfun</code>: function to compute the distance between point <code>xi</code> (vector) and  <code>xj</code>. Per default <code>distfun</code> is the Euclidian distance: <code>(xi,xj) -&gt; sqrt(sum(abs2,xi-xj)))</code>.</p></li><li><p><code>progress</code>: call-back function to show the progress of the optimization with the input parameters <code>iter</code>, <code>var</code>, <code>len</code> and <code>fitness</code> (all scalars).</p></li></ul><p>The length-scale parameters and the variance have the corresponding units from the <code>x</code> and <code>v</code>. It is therefore often necessary to provide reasonable values for these default parameters.</p><p>The algorithm used to estimate the correlation-length and variance is based on randomly choosen points. Therefore the result can be different if the function is invoked repeately. If <code>nmean</code> is increased, then these statistical fluctuations should decrease (for a not too large value of <code>mincount</code>, i.e. about 100 for most cases).</p><p>If the lower bound <code>minlen</code> is too small, then you might get the following error:</p><pre><code class="language-none">AmosException with id 4: input argument magnitude too large, complete loss of accuracy by argument reduction.</code></pre><p>In these case, increase <code>minlen</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/fit.jl#L235-L293">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DIVAnd.fit" href="#DIVAnd.fit"><code>DIVAnd.fit</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">var0opt,lensopt,distx,covar,fitcovar = fit(x,v,distbin,mincount;
         alpha = DIVAnd.alpha_default(length(x)),
         minlen = zeros(length(x)),
         maxlen = ones(length(x)),
         tolrel = 1e-4,
         lens0 = ones(length(x)),
         var0 = 1.,
         minvar0 = 0.,
         maxvar0 = 2.,
         maxpoints = 10000,
         distfun = (xi,xj,lens) -&gt; sqrt(sum(abs2,(xi-xj)./lens)),
         progress = (iter,var,len,fitness) -&gt; nothing
         )</code></pre><p>The same as the function <code>fit_isotropic</code> except that now the correlation length-scale <code>lens0</code>, <code>minlen</code>, <code>maxlen</code>, <code>lensopt</code> are vectors (one value per dimension). The distance function <code>distfun</code> uses an additional parameter to compute the normalized distance.</p><p>The note of the optional parameters in <code>divafit</code> also applies here.</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/fit.jl#L386-L407">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DIVAnd.DIVAnd_cv" href="#DIVAnd.DIVAnd_cv"><code>DIVAnd.DIVAnd_cv</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">bestfactorl,bestfactore, cvval,cvvalues, x2Ddata,y2Ddata,cvinter,xi2D,yi2D = DIVAnd_cv(mask,pmn,xi,x,f,len,epsilon2,nl,ne,method;...);</code></pre><p><strong>Input</strong></p><p>Same as for <code>DIVAndrun</code> with three more parameters <code>nl</code>,<code>ne</code> and <code>method</code></p><ul><li><p><code>mask</code>: binary mask delimiting the domain. true is inside and false outside. For oceanographic application, this is the land-sea mask.</p></li><li><p><code>pmn</code>: scale factor of the grid. pmn is a tuple with n elements. Every      element represents the scale factor of the corresponding dimension. Its      inverse is the local resolution of the grid in a particular dimension.</p></li><li><p><code>xi</code>: tuple with n elements. Every element represents a coordinate of the final grid on which the observations are interpolated</p></li><li><p><code>x</code>: tuple with n elements. Every element represents a coordinate of the observations</p></li><li><p><code>f</code>: value of the observations <em>minus</em> the background estimate (m-by-1 array).   (see note)</p></li><li><p><code>len</code>: correlation length</p></li><li><p><code>epsilon2</code>: error variance of the observations (normalized by the error variance of the background field). <code>epsilon2</code> can be a scalar (all observations have the same error variance and their errors are decorrelated), a vector (all observations can have a difference error variance and their errors are decorrelated) or a matrix (all observations can have a difference error variance and their errors can be correlated). If <code>epsilon2</code> is a scalar, it is thus the <em>inverse of the signal-to-noise ratio</em>.</p></li><li><p><code>nl</code>: number of testing points around the current value of L. <code>1</code> means one additional point on both sides of the current L. <code>0</code> is allowed and means the parameter is not optimised.</p></li><li><p><code>ne</code>: number of testing points around the current value of epsilon2. <code>0</code> is allowed as for <code>nl</code></p></li><li><p><code>method</code>: cross validation estimator method 1: full CV  2: sampled CV 3: GCV 0: automatic choice between the three possible ones, default value</p></li><li><p>Optional input arguments specified via keyword arguments are the same as for <code>DIVAnd</code></p></li></ul><p><strong>Output:</strong></p><ul><li><p><code>bestfactorl</code>: best estimate of the multiplication factor to apply to len</p></li><li><p><code>bestfactore</code>: best estimate of the multiplication factor to apply to epsilon2</p></li><li><p><code>cvvales</code> : the cross validation values calculated</p></li><li><p><code>factors</code> : the tested multiplication factors</p></li><li><p><code>cvinter</code> : interpolated cv values for final optimisation</p></li><li><p><code>X2Data, Y2Data</code> : coordinates of sampled cross validation in <code>L,epsilon2</code> space . Normally only used for debugging or plotting</p></li><li><p><code>Xi2D, Yi2D</code> : coordinates of interpolated estimator . Normally only used for debugging or plotting</p></li></ul><p>The output <code>bestfactorl</code> and <code>bestfactore</code> represent multiplication factors which should be applied to <code>L</code> and <code>epsilon2</code>.</p><p>The <code>len</code> and <code>epsilon2</code> provided should be close the real one as the tests will be performed around.</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/DIVAnd_cv.jl#L1-L66">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DIVAnd.empiriccovar" href="#DIVAnd.empiriccovar"><code>DIVAnd.empiriccovar</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">distx,covar,corr,varx,count = empiriccovar(x,v,distbin,mincount;
                          maxpoints = 10000,
                          distfun = (xi,xj) -&gt; sqrt(sum(abs2,xi-xj)))</code></pre><p>Compute the covariance, correlation and variance of a cloud of data points with the value <code>v</code> (a vector) and the location <code>x</code> (a tuple of vectors) grouped by distance. Random pairs are choosen and grouped by their distance (computed by <code>distfun</code>) in bins defined by <code>distbin</code>. The function try to fill at least <code>mincount</code> of data points in each bin but always stop after considering <code>maxpoints</code> pairs.</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/fit.jl#L64-L75">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DIVAnd.fithorzlen" href="#DIVAnd.fithorzlen"><code>DIVAnd.fithorzlen</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">lenz,dbinfo = DIVAnd.fithorzlen(x,value,z)</code></pre><p>Determines the horizontal correlation length <code>lenz</code> based on the measurments <code>value</code> at the location <code>x</code> (tuple of 3 vectors corresponding to longitude, latitude and depth).</p><p>Optional arguments:</p><ul><li><p><code>smoothz</code> (default 100): spatial filter for the correlation scale</p></li><li><p><code>searchz</code> (default 50): vertical search distance</p></li><li><p><code>maxnsamp</code> (default 5000): maximum number of samples</p></li><li><p><code>limitlen</code> (default false): limit correlation length by mean distance between observations</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/fit.jl#L932-L945">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DIVAnd.fitvertlen" href="#DIVAnd.fitvertlen"><code>DIVAnd.fitvertlen</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">lenz,dbinfo = DIVAnd.fitvertlen(x,value,z)</code></pre><p>See also DIVAnd.fithorzlen</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/fit.jl#L1006-L1010">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DIVAnd.lengraddepth" href="#DIVAnd.lengraddepth"><code>DIVAnd.lengraddepth</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">RL = lengraddepth(pmn,h, L;
                  h2 = h,
                  hmin = 0.001
                  )</code></pre><p>Create the relative correlation length-scale field <code>RL</code> based on the bathymetry  <code>h</code> and the metric <code>pmn</code> (tuple of arrays). Effectively the correlation-length  scale is close to zero if the relative bathymetry gradients (|∇h|/h) are smaller  than the length-scale <code>L</code> (in consistent units as <code>pmn</code>).</p><p>R_L = 1 / (1 + L |∇h| / max(h2,hmin))</p><p>Per default <code>h2</code> is equal to <code>h</code>. The depth <code>h</code> must be positive. <code>hmin</code> must  have the same units as h (usually meters).</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/utils.jl#L293-L309">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DIVAnd.DIVAnd_cvestimator" href="#DIVAnd.DIVAnd_cvestimator"><code>DIVAnd.DIVAnd_cvestimator</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">theta = DIVAnd_cvestimator(s,residual)</code></pre><p>Computes the cross validation estimator <span>$(d-\hat{d})^T \mathbf R^{-1} (d-\hat{d}) / ( \mathbf 1^T \mathbf R^{-1} \mathbf 1)$</span> where the <span>$\hat{d}$</span> is the analysis not using a data point.</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/DIVAnd_cvestimator.jl#L1-L7">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DIVAnd.weight_RtimesOne" href="#DIVAnd.weight_RtimesOne"><code>DIVAnd.weight_RtimesOne</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none"> weights = weight_RtimesOne(x,len)</code></pre><p>Compute the weight of the observations at location <code>x</code> to reduce the influence  of locally clustered data.  <code>x</code> is a tuple with n elements. Every element  represents a coordinate of the observations. <code>len</code> is a tuple of arrays representing the correlation length. <code>len[i]</code> is the correlation length in the  i-th dimension.</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/DIVAnd_weights.jl#L106-L114">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DIVAnd.Rtimesx!" href="#DIVAnd.Rtimesx!"><code>DIVAnd.Rtimesx!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">Rtimesx!(coord,LS,x,Rx)</code></pre><p>Gaussian type <code>R</code> matix in <code>ndim</code> dimensions applied to vector <code>x</code> of length  <code>ndata</code>. The Gaussian scale differs in each direction <code>k</code> : <code>LS[k]</code> Coordinates of point i are <code>coord[i,1],coord[i,2],...,coord[i,ndim]</code> To avoid an ndata² complexity a grid is set up first so as to allow only to calculate covarances when distances are smaller than <code>3*LS</code></p><p>Adapted from DIVA3D/src/Fortran/Util/Rtimesx_weighting.f90</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/DIVAnd_weights.jl#L1-L11">source</a></section><h1><a class="nav-anchor" id="Vocabulary-1" href="#Vocabulary-1">Vocabulary</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DIVAnd.Vocab.@urn_str" href="#DIVAnd.Vocab.@urn_str"><code>DIVAnd.Vocab.@urn_str</code></a> — <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">urn&quot;SDN:x:y:z&#39;</code></pre><p>Resolve a SeaDataNet URN (Uniform Resource Name) using https://www.seadatanet.org/urnurl/</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/Vocab.jl#L246-L251">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DIVAnd.Vocab.CFVocab" href="#DIVAnd.Vocab.CFVocab"><code>DIVAnd.Vocab.CFVocab</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">collection = Vocab.CFVocab()
collection = Vocab.CFVocab(url = url)</code></pre><p>Create a Dict-like object represeting the NetCDF CF Standard Name vocabulary. If the <code>url</code> is not provided then current CF Standard Name list http://cfconventions.org/Data/cf-standard-names/current/src/cf-standard-name-table.xml is used. Individual standard names are retirved by indexing which return an object of the type <code>CFEntry</code>:</p><pre><code class="language-julia">collection = Vocab.CFVocab()
entry = collection[&quot;sea_water_temperature&quot;]</code></pre></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/Vocab.jl#L30-L45">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.haskey-Tuple{DIVAnd.Vocab.CFVocab,Any}" href="#Base.haskey-Tuple{DIVAnd.Vocab.CFVocab,Any}"><code>Base.haskey</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">bool = haskey(collection::CFVocab,stdname)</code></pre><p>Return true if <code>stdname</code> is part of the NetCDF CF Standard Name vocabulary <code>collection</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/Vocab.jl#L62-L67">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DIVAnd.Vocab.SDNCollection" href="#DIVAnd.Vocab.SDNCollection"><code>DIVAnd.Vocab.SDNCollection</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">collection = SDNCollection(name)</code></pre><p>Open the SeaDataNet collection with the name <code>name</code> at the URL http://www.seadatanet.org/urnurl/collection/ The collection can be indexed with brackets using the identifier.</p><pre><code class="language-none">using DIVAnd
collection = Vocab.SDNCollection(&quot;P01&quot;)
concept = collection[&quot;PSALPR01&quot;]
@show Vocab.prefLabel(concept)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/Vocab.jl#L192-L205">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DIVAnd.Vocab.prefLabel" href="#DIVAnd.Vocab.prefLabel"><code>DIVAnd.Vocab.prefLabel</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">s = Vocab.prefLabel(c::Vocab.Concept)</code></pre><p>Return the preferred label of a concept <code>c</code></p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/Vocab.jl#L129-L133">source</a><div><pre><code class="language-none">s = Vocab.prefLabel(urn::AbstractString)</code></pre><p>Return the preferred label of a concept usings it URN (Uniform Resource Name)</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/Vocab.jl#L129-L133">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DIVAnd.Vocab.altLabel" href="#DIVAnd.Vocab.altLabel"><code>DIVAnd.Vocab.altLabel</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">s = Vocab.altLabel(c::Vocab.Concept)</code></pre><p>Return the alternative label of a concept <code>c</code></p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/Vocab.jl#L129-L133">source</a><div><pre><code class="language-none">s = Vocab.altLabel(urn::AbstractString)</code></pre><p>Return the alternative label of a concept usings it URN (Uniform Resource Name)</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/Vocab.jl#L129-L133">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DIVAnd.Vocab.notation" href="#DIVAnd.Vocab.notation"><code>DIVAnd.Vocab.notation</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">s = Vocab.notation(c::Vocab.Concept)</code></pre><p>Return the identifier of a concept <code>c</code></p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/Vocab.jl#L129-L133">source</a><div><pre><code class="language-none">s = Vocab.notation(urn::AbstractString)</code></pre><p>Return the identifier of a concept usings it URN (Uniform Resource Name)</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/Vocab.jl#L129-L133">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DIVAnd.Vocab.definition" href="#DIVAnd.Vocab.definition"><code>DIVAnd.Vocab.definition</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">s = Vocab.definition(c::Vocab.Concept)</code></pre><p>Return the definition of a concept <code>c</code></p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/Vocab.jl#L129-L133">source</a><div><pre><code class="language-none">s = Vocab.definition(urn::AbstractString)</code></pre><p>Return the definition of a concept usings it URN (Uniform Resource Name)</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/Vocab.jl#L129-L133">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DIVAnd.Vocab.resolve" href="#DIVAnd.Vocab.resolve"><code>DIVAnd.Vocab.resolve</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">entry = Vocab.resolve(urn)</code></pre><p>Resolve a SeaDataNet URN (Uniform Resource Name) and returns the corresponding EDMO entry or Vocabulary concept. For example:</p><pre><code class="language-julia">concept = Vocab.resolve(&quot;SDN:P021:current:TEMP&quot;)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/Vocab.jl#L95-L104">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.find-Tuple{DIVAnd.Vocab.Concept,Any,Any}" href="#Base.find-Tuple{DIVAnd.Vocab.Concept,Any,Any}"><code>Base.find</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">find(c::Concept,name,collection)</code></pre><p>Return a list of related concepts in the collection <code>collection</code>. <code>name</code> can be the string &quot;related&quot;, &quot;narrower&quot;, &quot;broader&quot;.</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/Vocab.jl#L156-L161">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DIVAnd.Vocab.description" href="#DIVAnd.Vocab.description"><code>DIVAnd.Vocab.description</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">str = description(entry::CFEntry)
str = canonical_units(entry::CFEntry)

Return the description or the canonical units of the `entry`.</code></pre></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/Vocab.jl#L70-L75">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DIVAnd.Vocab.canonical_units" href="#DIVAnd.Vocab.canonical_units"><code>DIVAnd.Vocab.canonical_units</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">str = description(entry::CFEntry)
str = canonical_units(entry::CFEntry)

Return the description or the canonical units of the `entry`.</code></pre></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/Vocab.jl#L70-L75">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DIVAnd.Vocab.splitURL" href="#DIVAnd.Vocab.splitURL"><code>DIVAnd.Vocab.splitURL</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">collection,tag,key = Vocab.splitURL(url)</code></pre><p>Split a concept URL into collection, tag and key. url must finishe with a slash.</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/Vocab.jl#L83-L88">source</a></section><h1><a class="nav-anchor" id="Internal-API-or-advanced-usage-1" href="#Internal-API-or-advanced-usage-1">Internal API or advanced usage</a></h1><h2><a class="nav-anchor" id="State-vector-1" href="#State-vector-1">State vector</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DIVAnd.statevector" href="#DIVAnd.statevector"><code>DIVAnd.statevector</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Initialize structure for packing and unpacking given their mask.</p><p>sv = statevector_init((mask1, mask2, ...))</p><p>Initialize structure for packing and unpacking multiple variables given their corresponding land-sea mask.</p><p>Input:   mask1, mask2,...: land-sea mask for variable 1,2,... Sea grid points correspond to one and land grid points to zero.     Every mask can have a different shape.</p><p>Output:   sv: structure to be used with statevector_pack and statevector_unpack.</p><p>Note: see also statevector_pack, statevector_unpack</p><p>Author: Alexander Barth, 2009,2017 &lt;a.barth@ulg.ac.be&gt; License: GPL 2 or later</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/statevector.jl#L24-L44">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DIVAnd.pack" href="#DIVAnd.pack"><code>DIVAnd.pack</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Pack a series of variables into a vector under the control of a mask.</p><p>x = pack(sv,(var1, var2, ...))</p><p>Pack the different variables var1, var2, ... into the vector x where <code>sv</code> is a <code>statevector</code>. Only sea grid points are retained.</p><p>Input:   sv: structure generated by statevector_init.   var1, var2,...: variables to pack (with the same shape as the corresponding masks).</p><p>Output:   x: vector of the packed elements. The size of this vector is the number of elements of all masks equal to 1.</p><p>Notes: If var1, var2, ... have an additional trailing dimension, then this dimension is assumed to represent the different ensemble members. In this case x is a matrix and its last dimension is the number of ensemble members.</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/statevector.jl#L76-L95">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DIVAnd.unpack" href="#DIVAnd.unpack"><code>DIVAnd.unpack</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Unpack a vector into different variables under the control of a mask.</p><p>var1, var2, ... = unpack(sv,x) var1, var2, ... = unpack(sv,x,fillvalue)</p><p>Unpack the vector x into the different variables var1, var2, ... where <code>sv</code> is a <code>statevector</code>.</p><p>Input:   sv: structure generated by statevector_init.   x: vector of the packed elements. The size of this vector is the number of elements equal to 1     in all masks.</p><p>Optional input parameter:   fillvalue: The value to fill in var1, var2,... where the masks correspond to a land grid point. The default is zero.</p><p>Output:   var1, var2,...: unpacked variables.</p><p>Notes: If x is a matrix, then the second dimension is assumed to represent the different ensemble members. In this case, var1, var2, ... have also an additional trailing dimension.</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/statevector.jl#L129-L153">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.sub2ind" href="#Base.sub2ind"><code>Base.sub2ind</code></a> — <span class="docstring-category">Function</span>.</div><div><p>ind = statevector_sub2ind(sv,subscripts)</p><p>Compute from a tuple of subscripts the linear index in the packed state vector. The first element of the subscript indicates the variable index and the remaining the spatial subscripts.</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/statevector.jl#L209-L214">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.ind2sub" href="#Base.ind2sub"><code>Base.ind2sub</code></a> — <span class="docstring-category">Function</span>.</div><div><p>subscripts = ind2ind(sv,index)</p><p>Compute from linear index in the packed state vector a tuple of subscripts. The first element of the subscript indicates the variable index and the remaining the spatial subscripts.</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/statevector.jl#L187-L192">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.length" href="#Base.length"><code>Base.length</code></a> — <span class="docstring-category">Function</span>.</div><div><p>number of points per node it is always zero for non-leaf nodes</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/Quadtrees.jl#L125-L128">source</a></section><h2><a class="nav-anchor" id="Constraints-1" href="#Constraints-1">Constraints</a></h2><pre><code class="language-none">DIVAnd_constr_fluxes
DIVAnd_constr_constcoast</code></pre><h2><a class="nav-anchor" id="ODV-files-1" href="#ODV-files-1">ODV files</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DIVAnd.ODVspreadsheet.listSDNparams" href="#DIVAnd.ODVspreadsheet.listSDNparams"><code>DIVAnd.ODVspreadsheet.listSDNparams</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">p = listSDNparam(ODVData)

Return a list of SeaDataNet P01 parameters in a ODV spreadsheet `ODVData`.</code></pre></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/ODVspreadsheet.jl#L249-L253">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DIVAnd.ODVspreadsheet.load" href="#DIVAnd.ODVspreadsheet.load"><code>DIVAnd.ODVspreadsheet.load</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none"> profiles,lons,lats,depths,times,ids = load(T,fnames,datanames;
    qv_flags = [DIVAnd.ODVspreadsheet.GOOD_VALUE,
                DIVAnd.ODVspreadsheet.PROBABLY_GOOD_VALUE],
    nametype = :P01,
    qvlocalname = &quot;QV:SEADATANET&quot;)</code></pre><p>Load all profiles in all file from the array <code>fnames</code> corresponding to one of the parameter names <code>datanames</code>. If <code>nametype</code> is <code>:P01</code> (default), the datanames are P01 vocabulary names with the SDN prefix. If nametype is <code>:localname</code>, then they are the ODV column header without units. For example if the column header is <code>Water body salinity [per mille]</code>, then <code>datenames</code> should be <code>[&quot;Water body salinity&quot;]</code>. The resulting vectors have the data type <code>T</code> (expect <code>times</code> and <code>ids</code> which are vectors of <code>DateTime</code> and <code>String</code> respectively). Only values matching the quality flag <code>qv_flags</code> are retained. <code>qv_flags</code> is a vector of Strings (based on http://vocab.nerc.ac.uk/collection/L20/current/, e.g. &quot;1&quot; means &quot;good value&quot;). One can also use the constants these constants (prefixed with <code>DIVAnd.ODVspreadsheet.</code>):</p><p><code>qvlocalname</code> is the column name to denote quality flags. It is assumed that the quality flags follow immediatly the data column.</p><table><tr><th>constant</th><th>value</th></tr><tr><td>NO_QUALITY_CONTROL</td><td>&quot;0&quot;</td></tr><tr><td>GOOD_VALUE</td><td>&quot;1&quot;</td></tr><tr><td>PROBABLY_GOOD_VALUE</td><td>&quot;2&quot;</td></tr><tr><td>PROBABLY_BAD_VALUE</td><td>&quot;3&quot;</td></tr><tr><td>BAD_VALUE</td><td>&quot;4&quot;</td></tr><tr><td>CHANGED_VALUE</td><td>&quot;5&quot;</td></tr><tr><td>VALUE_BELOW_DETECTION</td><td>&quot;6&quot;</td></tr><tr><td>VALUE_IN_EXCESS</td><td>&quot;7&quot;</td></tr><tr><td>INTERPOLATED_VALUE</td><td>&quot;8&quot;</td></tr><tr><td>MISSING_VALUE</td><td>&quot;9&quot;</td></tr><tr><td>VALUE_PHENOMENON_UNCERTAIN</td><td>&quot;A&quot;</td></tr></table><p>If the ODV does not contain a semantic header (e.g. for the aggregated ODV files), then local names must be used.</p><pre><code class="language-julia-repl">julia&gt; data,lon,lat,depth,time,ids = DIVAnd.ODVspreadsheet.load(Float64,[&quot;data_from_med_profiles_non-restricted_v2.txt&quot;],
      [&quot;Water body salinity&quot;]; nametype = :localname );</code></pre><p>No checks are done if the units are consistent.</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/ODVspreadsheet.jl#L557-L605">source</a><div><pre><code class="language-none"> profiles,lons,lats,depths,times,ids = load(T,dir,P01names)</code></pre><p>Load all ODV files under the directory <code>dir</code> corresponding the one of the parameter names <code>P01names</code>. The resulting vectors have the data type <code>T</code> (expect <code>times</code> and <code>ids</code> which are vectors of <code>DateTime</code> and <code>String</code> respectively).</p><p>No checks are done if the units are consistent.</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/ODVspreadsheet.jl#L678-L687">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DIVAnd.ODVspreadsheet.localnames" href="#DIVAnd.ODVspreadsheet.localnames"><code>DIVAnd.ODVspreadsheet.localnames</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">list = localnames(sheet,P01name)</code></pre><p>Return a list <code>list</code> of all local names mapping to the specified <code>P01name</code> in the ODV spreadsheet <code>sheet</code> without the prefix &quot;SDN:LOCAL:&quot;.</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/ODVspreadsheet.jl#L272-L278">source</a><div><pre><code class="language-none">list = localnames(sheet)</code></pre><p>Return a list <code>list</code> of all local names  in the ODV spreadsheet <code>sheet</code> without the prefix &quot;SDN:LOCAL:&quot; in the order as they appear in the ODV file.</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/ODVspreadsheet.jl#L281-L287">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DIVAnd.ODVspreadsheet.Spreadsheet" href="#DIVAnd.ODVspreadsheet.Spreadsheet"><code>DIVAnd.ODVspreadsheet.Spreadsheet</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Define composite type that will contain:</p><ul><li><p>the metadata (dictionary),</p></li><li><p>SDN parameter mapping (dictionary)</p></li><li><p>the column labels (array) and</p></li><li><p>the profiles (array of arrays).</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/ODVspreadsheet.jl#L26-L32">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DIVAnd.ODVspreadsheet.loadprofile" href="#DIVAnd.ODVspreadsheet.loadprofile"><code>DIVAnd.ODVspreadsheet.loadprofile</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none"> data,data_qv,obslon,obslat,obsdepth,obsdepth_qv,obstime,obstime_qv,EDMO,LOCAL_CDI_ID =
 loadprofile(T,sheet,iprofile,dataname; nametype = :P01)</code></pre><p>Load a <code>iprofile</code>-th profile from the ODV spreadsheet <code>sheet</code> of the parameter <code>dataname</code>. If <code>nametype</code> is <code>:P01</code> (default), the dataname is the P01 vocabulary name with the SDN prefix. If nametype is <code>:localname</code>, then it is the ODV column header.  The resulting vectors have the data type <code>T</code> (expect the quality flag and <code>obstime</code>) .</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/ODVspreadsheet.jl#L432-L442">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DIVAnd.ODVspreadsheet.loaddataqv" href="#DIVAnd.ODVspreadsheet.loaddataqv"><code>DIVAnd.ODVspreadsheet.loaddataqv</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">data,data_qv = loaddataqv(sheet,profile,locname,fillvalue; fillmode = :repeat)</code></pre><p>The same as <code>loaddata</code>, but now the quality flag are also loaded.</p><p>profile[i][j] is the j-th column of the i-th row of a profile. profile[i,j] is the i-th column of the j-th row of a profile.</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/ODVspreadsheet.jl#L393-L400">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DIVAnd.ODVspreadsheet.SDNparse!" href="#DIVAnd.ODVspreadsheet.SDNparse!"><code>DIVAnd.ODVspreadsheet.SDNparse!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">SDNparse!(col,fillmode,fillvalue,data)</code></pre><p>Parse the list of String <code>col</code> into the corresponding data type of the vector <code>data</code>. Empty values are either replaced by <code>fillvalue</code> (if fillmode is :fill) or the previous value if repeated (if fillmode is :repeat)</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/ODVspreadsheet.jl#L335-L342">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DIVAnd.ODVspreadsheet.colnumber" href="#DIVAnd.ODVspreadsheet.colnumber"><code>DIVAnd.ODVspreadsheet.colnumber</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">cn = colnumber(sheet,localname)</code></pre><p>Return the column number <code>cn</code> of the first column with the local name <code>localname</code> (without the prefix &quot;SDN:LOCAL:&quot;) in the ODV spreadsheet <code>sheet</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/ODVspreadsheet.jl#L290-L295">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DIVAnd.ODVspreadsheet.nprofiles" href="#DIVAnd.ODVspreadsheet.nprofiles"><code>DIVAnd.ODVspreadsheet.nprofiles</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">n = nprofiles(ODVData)</code></pre><p>Return the number of profiles in a ODV Spreadsheet <code>ODVData</code> loaded by <code>readODVspreadsheet</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/ODVspreadsheet.jl#L46-L51">source</a></section><h2><a class="nav-anchor" id="Operators-1" href="#Operators-1">Operators</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DIVAnd.sparse_interp" href="#DIVAnd.sparse_interp"><code>DIVAnd.sparse_interp</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">H,out = sparse_interp(mask,I)</code></pre><p>Create interpolation matrix from <code>mask</code> and fractional indexes <code>I</code>.</p><p>Input:   mask: 0 invalid and 1 valid points (n-dimensional array)   I: fractional indexes (2-dim array n by mi, where mi is the number of points to interpolate) Ouput:   H: sparse matrix with interpolation coefficients   out: true if value outside of grid   outbbox: 1 if outise bouding box   onland: 1 if point touches land (where mask == 0)</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/sparse_interp.jl#L1-L14">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DIVAnd.sparse_interp_g" href="#DIVAnd.sparse_interp_g"><code>DIVAnd.sparse_interp_g</code></a> — <span class="docstring-category">Function</span>.</div><div><p>sparse_interp(x,mask,xi) Interpolate from x onto xi</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/sparse_interp.jl#L109-L112">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DIVAnd.sparse_gradient" href="#DIVAnd.sparse_gradient"><code>DIVAnd.sparse_gradient</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Sparse operator for a gradient. Dx1,Dx2,...,Dxn = sparse_gradient(mask,pmn) Form the gradient using finite differences in all n-dimensions Input:   mask: binary mask delimiting the domain. 1 is inside and 0 outside.         For oceanographic application, this is the land-sea mask.   pmn: scale factor of the grid. Output:   Dx1,Dx2,...,Dxn: operators represeting a gradient along     different dimensions</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/sparse_gradient.jl#L1-L12">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DIVAnd.sparse_diff" href="#DIVAnd.sparse_diff"><code>DIVAnd.sparse_diff</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">diffx = sparse_diff(sz1,m,cyclic)</code></pre><p>Sparse operator for differentiation along dimension <code>m</code> for &quot;collapsed&quot; matrix of the size <code>sz1</code>. <code>cyclic</code> is true if domain is cyclic along dimension m. <code>false</code> is the default value</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/sparse_diff.jl#L45-L51">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DIVAnd.matfun_trim" href="#DIVAnd.matfun_trim"><code>DIVAnd.matfun_trim</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">T = matfun_trim(sz1,m)</code></pre><p>Create an operator which trim first and last row (or column) in The field is a &quot;collapsed&quot; matrix of the size <code>sz1</code>. <code>m</code> is the dimension  to trim.</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/function_operator.jl#L186-L192">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DIVAnd.matfun_stagger" href="#DIVAnd.matfun_stagger"><code>DIVAnd.matfun_stagger</code></a> — <span class="docstring-category">Function</span>.</div><div><p>S = matfun_stagger(sz1,m,cyclic)</p><p>Create an operator for staggering a field in dimension m. The field is a &quot;collapsed&quot; matrix of the size sz1.</p><p>Input:   sz1: size of rhs   m: dimension to stagger   cyclic: true if domain is cyclic along dimension m. False is the   default value</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/function_operator.jl#L136-L147">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DIVAnd.matfun_diff" href="#DIVAnd.matfun_diff"><code>DIVAnd.matfun_diff</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Operator for differentiation.</p><p>diffx = matfun_diff(sz1,m,cyclic)</p><p>Operator for differentiation along dimension m for &quot;collapsed&quot; matrix of the size sz1.</p><p>Input:   sz1: size of rhs   m: dimension to differentiate   cyclic: true if domain is cyclic along dimension m. False is the   default value</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/function_operator.jl#L36-L49">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DIVAnd.matfun_shift" href="#DIVAnd.matfun_shift"><code>DIVAnd.matfun_shift</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Operator shifting a field in a given dimension.</p><p>function S = matfun_shift(sz1,m,cyclic)</p><p>Operator shifting a field in the dimension m. The field is a &quot;collapsed&quot; matrix of the size sz1.</p><p>Input:   sz1: size of rhs   m: dimension to shift   cyclic: true if domain is cyclic along dimension m. False is the     default value</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/function_operator.jl#L89-L102">source</a></section><h2><a class="nav-anchor" id="Quadtree-1" href="#Quadtree-1">Quadtree</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DIVAnd.Quadtrees.QT" href="#DIVAnd.Quadtrees.QT"><code>DIVAnd.Quadtrees.QT</code></a> — <span class="docstring-category">Type</span>.</div><div><p>quadtree (of the higher-dimensional equivalent) T the type of the coordinates TA the type of the attributes N number of dimensions</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/Quadtrees.jl#L6-L11">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DIVAnd.Quadtrees.rsplit!" href="#DIVAnd.Quadtrees.rsplit!"><code>DIVAnd.Quadtrees.rsplit!</code></a> — <span class="docstring-category">Function</span>.</div><div><p>recursive split</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/Quadtrees.jl#L277-L279">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DIVAnd.Quadtrees.add!" href="#DIVAnd.Quadtrees.add!"><code>DIVAnd.Quadtrees.add!</code></a> — <span class="docstring-category">Function</span>.</div><div><p>sucess = add!(qt,x,attrib,max_cap = 10) Add point <code>x</code> with the attribute <code>attrib</code> to the quadtree <code>qt</code>. <code>sucess</code> is true if <code>x</code>is within the bounds of the quadtree node <code>qt</code> (otherwise false and the point has not been added)</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/Quadtrees.jl#L150-L155">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DIVAnd.Quadtrees.within" href="#DIVAnd.Quadtrees.within"><code>DIVAnd.Quadtrees.within</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">attribs = within(qt,min,max)</code></pre><p>Search all points within a bounding box defined by the vectors <code>min</code> and <code>max</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/Quadtrees.jl#L311-L315">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DIVAnd.Quadtrees.bitget" href="#DIVAnd.Quadtrees.bitget"><code>DIVAnd.Quadtrees.bitget</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Test if the n-th bit in a is set. The least significant bit is n = 1.</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/Quadtrees.jl#L72-L74">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DIVAnd.Quadtrees.inside" href="#DIVAnd.Quadtrees.inside"><code>DIVAnd.Quadtrees.inside</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">         x1</code></pre><p>+–––––+   |          |   |   +      |   |   y      |   +–––––+  x0</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/Quadtrees.jl#L53-L62">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DIVAnd.Quadtrees.intersect" href="#DIVAnd.Quadtrees.intersect"><code>DIVAnd.Quadtrees.intersect</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Test of the rectanges defined by x0,x1  and y0,y1 intersects              x1   +–––––+   |          |   |   +–––––+ y1   |   |      |   |   +–––––+   |  x0   |          |       |          |       +–––––+      y0</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/Quadtrees.jl#L103-L115">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DIVAnd.Quadtrees.split!" href="#DIVAnd.Quadtrees.split!"><code>DIVAnd.Quadtrees.split!</code></a> — <span class="docstring-category">Function</span>.</div><div><p>split a single node</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/Quadtrees.jl#L225-L227">source</a></section><h2><a class="nav-anchor" id="Conjugate-gradient-1" href="#Conjugate-gradient-1">Conjugate gradient</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DIVAnd.conjugategradient" href="#DIVAnd.conjugategradient"><code>DIVAnd.conjugategradient</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">x,success,niter = conjugategradient(fun!,b)</code></pre><p>Solve a linear system with the preconditioned conjugated-gradient method: A x = b where <code>A</code> is a symmetric positive defined matrix and <code>b</code> is a vector.  Equivalently the solution <code>x</code> minimizes the cost function  J(x) = ½ xᵀ A x - bᵀ x.</p><p>The function <code>fun!(x,fx)</code> computes fx which is equal to  <code>A*x</code>. For example:</p><pre><code class="language-none">function fun!(x,fx)
    fx[:] = A*x
end</code></pre><p>Note that the following code will NOT work, because a new array <code>fx</code> would be created and it would not be passed back to the caller.</p><pre><code class="language-none">function fun!(x,fx)
    fx = A*x # bug!
end</code></pre><p>The function <code>fun!</code> works in-place to reduce the amount of memory allocations.</p><p><strong>Optional input arguments</strong></p><ul><li><p><code>x0</code>: starting vector for the interations</p></li><li><p><code>tol</code>: tolerance on  |Ax-b| / |b|</p></li><li><p><code>maxit</code>: maximum of interations</p></li><li><p><code>pc!</code>: the preconditioner. The functions <code>pc(x,fx)</code> computes fx = M⁻¹ x (the inverse of M times x) where <code>M</code> is a symmetric positive defined matrix. Effectively, the system E⁻¹ A (E⁻¹)ᵀ (E x) = E⁻¹ b is solved for (E x) where E Eᵀ = M. Ideally, M should this be similar to A, so that E⁻¹ A (E⁻¹)ᵀ is close to the identity matrix. The function <code>pc!</code> should be implemented in a similar way than <code>fun!</code> (see above).</p></li></ul><p><strong>Output</strong></p><ul><li><p><code>x</code>: the solution</p></li><li><p><code>success</code>: true if the interation converged (otherwise false)</p></li><li><p><code>niter</code>: the number of iterations</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/conjugategradient.jl#L55-L92">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DIVAnd.pc_none!" href="#DIVAnd.pc_none!"><code>DIVAnd.pc_none!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">pc_none!(x,fx)</code></pre><p>Dummy call-back function when no preconditioner is used. <code>fx</code> will be equal to <code>x</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/conjugategradient.jl#L2-L6">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DIVAnd.checksym" href="#DIVAnd.checksym"><code>DIVAnd.checksym</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">xAy, yATx = checksym(n,fun!)</code></pre><p>Check if the the function <code>fun!</code> represents a symmetric matrix when applied on  random vectors of size <code>n</code>. </p></div><a class="source-link" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/c926000ef28ad779c5d7d0857a8a27596a4b8646/src/conjugategradient.jl#L11-L16">source</a></section><h2><a class="nav-anchor" id="Utility-functions-1" href="#Utility-functions-1">Utility functions</a></h2><pre><code class="language-none">DIVAnd.DIVAnd_laplacian
DIVAnd.DIVAnd_obscovar
DIVAnd.DIVAnd_adaptedeps2
DIVAnd.DIVAnd_diagHKobs
DIVAnd.DIVAnd_residual
DIVAnd.DIVAnd_addc
DIVAnd.DIVAnd_erroratdatapoints
DIVAnd.DIVAnd_iBpHtiRHx!
DIVAnd.DIVAnd_GCVKii
DIVAnd.DIVAnd_fittocpu
DIVAnd.DIVAnd_background
DIVAnd.DIVAnd_obs
DIVAnd.DIVAnd_bc_stretch
DIVAnd.DIVAnd_diagHK
DIVAnd.DIVAnd_kernel
DIVAnd.DIVAnd_residualobs
DIVAnd.DIVAnd_aexerr
DIVAnd.DIVAnd_cpme
DIVAnd.DIVAnd_cpme_go
DIVAnd.DIVAnd_datainboundingbox
DIVAnd.DIVAnd_Lpmnrange
DIVAnd.DIVAnd_pc_sqrtiB
DIVAnd.DIVAnd_pc_none
DIVAnd.DIVAnd_GCVKiiobs
DIVAnd.DIVAnd_cutter
DIVAnd.DIVAnd_qc
DIVAnd.DIVAnd_solve!
DIVAnd.DIVAnd_sampler
DIVAnd.DIVAndjog
DIVAnd.DIVAnd_background_components
DIVAnd.stats
DIVAnd.statpos
DIVAnd.blkdiag
Base.findfirst
DIVAnd.formatsize
DIVAnd.interp!
DIVAnd.ufill
DIVAnd.jmBix
DIVAnd.cgradient
DIVAnd.fzero
DIVAnd.localize_separable_grid
DIVAnd.decompB!
DIVAnd.varanalysis
DIVAnd.len_harmonize
DIVAnd.alpha_default
DIVAnd.ncfile
DIVAnd.writeslice
DIVAnd.encodeWMSStyle
DIVAnd.loadoriginators</code></pre><h1><a class="nav-anchor" id="Examples-1" href="#Examples-1">Examples</a></h1><p>To run the example, you need to install <code>PyPlot</code>. In the folder <code>examples</code> of DIVAnd, you can run e.g. the example <code>DIVAnd_simple_example_1D.jl</code> by issuing:</p><pre><code class="language-julia"># cd(&quot;/path/to/DIVAnd/examples&quot;)
include(&quot;DIVAnd_simple_example_1D.jl&quot;)</code></pre><p>Replace <code>/path/to/DIVAnd/</code> by the installation directory of DIVAnd which is the output of <code>Pkg.dir(&quot;DIVAnd&quot;)</code> if you installed <code>DIVAnd</code> using Julias package manager.</p><h1><a class="nav-anchor" id="Performance-considerations-1" href="#Performance-considerations-1">Performance considerations</a></h1><h2><a class="nav-anchor" id="Tuning-the-domain-decomposition-1" href="#Tuning-the-domain-decomposition-1">Tuning the domain decomposition</a></h2><p>The functions <code>diva3d</code> and <code>DIVAndgo</code> split the domain into overlapping subdomains to reduce the required amount of memory. In some circumstances (in particular few vertical levels), this can unnecessarily degrade the performance. The CPU time of the analysis can be improved by increasing the <code>diva3d</code> option <code>memtofit</code> from 3 (default) to higher values (as long as one does not run out of memory). If this parameter is set to a very high value then the domain decomposition is effectively disabled.</p><h2><a class="nav-anchor" id="Multiple-CPU-system-1" href="#Multiple-CPU-system-1">Multiple CPU system</a></h2><p>Per default julia tries to use all CPUs on your system when doing matrix operations. The number of CPUs is controlled by the call to <code>BLAS.set_num_threads</code>. Using multiple CPUs can result in overhead and it can be beneficial to reduce the number of CPUs:</p><pre><code class="language-julia">BLAS.set_num_threads(2)</code></pre><h1><a class="nav-anchor" id="Information-for-developers-1" href="#Information-for-developers-1">Information for developers</a></h1><h2><a class="nav-anchor" id="Update-the-documentation-1" href="#Update-the-documentation-1">Update the documentation</a></h2><p>Install</p><pre><code class="language-julia">Pkg.add(&quot;Documenter&quot;)</code></pre><h1><a class="nav-anchor" id="Troubleshooting-1" href="#Troubleshooting-1">Troubleshooting</a></h1><p>If the installation of a package fails, it is recommended to update the local copy of the package list by issuing <code>Pkg.update()</code> to make sure that Julia knows about the latest version of these packages and then to re-try the installation of the problematic package. Julia calls the local copy of the packge list <code>METADATA</code>. For example to retry the installation of EzXML issue the following command:</p><pre><code class="language-julia">Pkg.update()
Pkg.add(&quot;EzXML&quot;)</code></pre><h2><a class="nav-anchor" id="No-plotting-window-appears-1" href="#No-plotting-window-appears-1">No plotting window appears</a></h2><p>If the following command doesn&#39;t produce any figure</p><pre><code class="language-julia">using PyPlot
plot(1:10)</code></pre><p>A possible solution is to modify the <em>backend</em>: this is done by editing the python configuration file <a href="http://matplotlib.org/users/customizing.html#the-matplotlibrc-file">matplotlibrc</a>. The location of this file is obtained in python with:</p><pre><code class="language-python">import matplotlib
matplotlib.matplotlib_fname</code></pre><p>Under Linux, this returns <code>&#39;~/.config/matplotlib/matplotlibrc&#39;</code>. To use the <code>TkAgg</code> backend, add the following to the file:</p><pre><code class="language-none">backend      : TkAgg</code></pre><p>The <code>matplotlibrc</code> need to be created if it does not exists.</p><h2><a class="nav-anchor" id="Julia-cannot-connect-to-GitHub-on-Windows-7-and-Windows-Server-2012-1" href="#Julia-cannot-connect-to-GitHub-on-Windows-7-and-Windows-Server-2012-1">Julia cannot connect to GitHub on Windows 7 and Windows Server 2012</a></h2><p>Cloning METADATA or downloading a julia packages fails with:</p><pre><code class="language-none">GitError(Code:ECERTIFICATE, Class:OS, , user cancelled certificate checks: )</code></pre><p>The problem is that Windows 7 and Windows Server 2012 uses outdated encryption protocols. The solution is to run the &quot;Easy fix&quot; tool from the <a href="https://stackoverflow.com/questions/49065986/installation-of-julia-on-windows7-64-bit">Microsoft support page</a></p><h2><a class="nav-anchor" id="MbedTLS.jl-does-not-install-on-Windows-7-1" href="#MbedTLS.jl-does-not-install-on-Windows-7-1">MbedTLS.jl does not install on Windows 7</a></h2><p>The installion of <code>MbedTLS.jl</code> fails with the error message:</p><pre><code class="language-none">INFO: Building MbedTLS                                                                                                                                    
Info: Downloading https://github.com/quinnj/MbedTLSBuilder/releases/download/v0.6/MbedTLS.x86_64-w64-mingw32.tar.gz to C:\Users\Jeremy\.julia\v0.6\MbedTLS
\deps\usr\downloads\MbedTLS.x86_64-w64-mingw32.tar.gz...                                                                                                  
Exception setting &quot;SecurityProtocol&quot;: &quot;Cannot convert null to type &quot;System.Net.SecurityProtocolType&quot; due to invalid enumeration values. Specify one of th
e following enumeration values and try again. The possible enumeration values are &quot;Ssl3, Tls&quot;.&quot;                                                           
At line:1 char:35                                                                                                                                         
+ [System.Net.ServicePointManager]:: &lt;&lt;&lt;&lt; SecurityProtocol =                                                                                              
    + CategoryInfo          : InvalidOperation: (:) [], RuntimeException                                                                                  
    + FullyQualifiedErrorId : PropertyAssignmentException                                                                                                 
    [...]</code></pre><p>See also the issue https://github.com/JuliaWeb/MbedTLS.jl/issues/133</p><p>The solution is to install the <a href="https://www.microsoft.com/en-us/download/details.aspx?id=40855">Windows Management Framework 4.0</a>.</p><h2><a class="nav-anchor" id="EzXML.jl-cannot-be-installed-on-RedHat-6-1" href="#EzXML.jl-cannot-be-installed-on-RedHat-6-1">EzXML.jl cannot be installed on RedHat 6</a></h2><p>The <code>zlib</code> library of RedHat 6, is slightly older than the library which <code>EzXML.jl</code> and <code>libxml2</code> requires.</p><p>To verify this issue, you can type in Julia</p><pre><code class="language-none">Libdl.dlopen(joinpath(Pkg.dir(&quot;EzXML&quot;),&quot;deps/usr/lib/libxml2.so&quot;))</code></pre><p>It should not return an error message. On Redhat 6.6, the following error message is returned:</p><pre><code class="language-none">ERROR: could not load library &quot;/home/username/.julia/v0.6/EzXML/deps/usr/lib/libxml2.so&quot;

/lib64/libz.so.1: version `ZLIB_1.2.3.3&#39; not found (required by /home/divahs1/.julia/v0.6/EzXML/deps/usr/lib/libxml2.so)

Stacktrace:

 [1] dlopen(::String, ::UInt32) at ./libdl.jl:97 (repeats 2 times)</code></pre><p>However, the following command should work:</p><pre><code class="language-julia"> LD_LIBRARY_PATH=&quot;$HOME/.julia/v0.6/EzXML/deps/usr/lib/:$LD_LIBRARY_PATH&quot; julia --eval  &#39;print(Libdl.dlopen(joinpath(Pkg.dir(&quot;EzXML&quot;),&quot;deps/usr/lib/libxml2.so&quot;))&#39;</code></pre><p>Lukily, EzZML.jl includes a newer version of the <code>zlib</code> library, but it does not load the library automatically. (see also https://github.com/JuliaLang/julia/issues/7004 and https://github.com/JuliaIO/HDF5.jl/issues/97)</p><p>To make Julia use this library, a user on RedHat 6 should always start Julia with:</p><pre><code class="language-bash">LD_LIBRARY_PATH=&quot;$HOME/.julia/v0.6/EzXML/deps/usr/lib/:$LD_LIBRARY_PATH&quot; julia</code></pre><p>One can also create script with the following content:</p><pre><code class="language-bash">#!/bin/bash
export LD_LIBRARY_PATH=&quot;$HOME/.julia/v0.6/EzXML/deps/usr/lib/:$LD_LIBRARY_PATH&quot;
exec /path/to/bin/julia &quot;$@&quot;</code></pre><p>by replacing <code>/path/to/bin/julia</code> to the full path of your installation directory. The script should be marked executable and it can be included in your Linux search <a href="http://www.linfo.org/path_env_var.html"><code>PATH</code> environement variable</a>. Julia can then be started by calling directly this script.</p><h2><a class="nav-anchor" id="The-DIVAnd-test-suite-fails-with-automatic-download-failed-1" href="#The-DIVAnd-test-suite-fails-with-automatic-download-failed-1">The DIVAnd test suite fails with <code>automatic download failed</code></a></h2><p>Running <code>Pkg.test(&quot;DIVAnd&quot;)</code> fails with the error:</p><pre><code class="language-julia">automatic download failed (error: 2147500036)</code></pre><p>The test suite will download some sample data. You need to have internet access and run the test function from a directory with write access.</p><p>You can change the directory to your home directory with the julia command <code>cd(homedir())</code>.</p><p>You can check the current working directory with:</p><pre><code class="language-julia">pwd()</code></pre><h2><a class="nav-anchor" id="METADATA-cannot-be-updated-1" href="#METADATA-cannot-be-updated-1">METADATA cannot be updated</a></h2><p><code>Pkg.update</code> fails with the error message <code>METADATA cannot be updated</code>.</p><p>If you have git installed, you can issue the command:</p><pre><code class="language-bash">cd ~/.julia/v0.6/METADATA
git reset --hard</code></pre><p>and then in Julia run <code>Pkg.update()</code> again.</p><p>If this does not work, then, you can also delete <code>~/.julia</code> (https://github.com/JuliaLang/julia/issues/18651#issuecomment-347579521) and in Julia enter <code>Pkg.init(); Pkg.update()</code>.</p><h2><a class="nav-anchor" id="Convert-error-in-DIVAnd_obs-1" href="#Convert-error-in-DIVAnd_obs-1">Convert error in <code>DIVAnd_obs</code></a></h2><p>The full error message:</p><pre><code class="language-none">MethodError: Cannot `convert` an object of type DIVAnd.DIVAnd_constrain{Float32,Diagonal{Float64},SparseMatrixCSC{Float64,Int64}} to an object of type DIVAnd.DIVAnd_constrain{Float64,TR,TH} where TH&lt;:(AbstractArray{#s370,2} where #s370&lt;:Number) where TR&lt;:(AbstractArray{#s371,2} where #s371&lt;:Number)
This may have arisen from a call to the constructor DIVAnd.DIVAnd_constrain{Float64,TR,TH} where TH&lt;:(AbstractArray{#s370,2} where #s370&lt;:Number) where TR&lt;:(AbstractArray{#s371,2} where #s371&lt;:Number)(...),
since type constructors fall back to convert methods.</code></pre><p>The solution is to use the same type of all input parameters: all Float32 or all Float64.</p><h2><a class="nav-anchor" id="Monthlist-issue-1" href="#Monthlist-issue-1">Monthlist issue</a></h2><p>Using comments inside list can lead to unexpected results.</p><p>This</p><pre><code class="language-julia"> monthlist = [
       [1,2,3]
       #[4,5,6]
       ]</code></pre><p>should be written as</p><pre><code class="language-julia"> monthlist = [
       [1,2,3]
       ]</code></pre><h2><a class="nav-anchor" id="Error-in-the-factorisation-1" href="#Error-in-the-factorisation-1">Error in the factorisation</a></h2><p>The following message</p><pre><code class="language-julia">Base.LinAlg.PosDefException(95650)</code></pre><p>followed by the stack-trace starting with: <code>julia Stacktrace:  [1] #cholfact!#8(::Float64, ::Function, ::Base.SparseArrays.CHOLMOD.Factor{Float64}, ::Base.SparseArrays.CHOLMOD.Sparse{Float64}) at ./sparse/cholmod.jl:1360  .................  [9] DIVAndrun(::BitArray{3}, ::Tuple{Array{Float64,3},Array{Float64,3},Array{Float64,3}}, ::Tuple{Array{Float64,3},Array{Float64,3},Array{Float64,3}}, ::Tuple{Array{Float64,1},Array{Float64,1},Array{Float64,1}}, ::Array{Float64,1}, ::Tuple{Array{Float64,3},Array{Float64,3},Array{Float64,3}}, ::Float64) at /home/ctroupin/.julia/v0.6/DIVAnd/src/DIVAndrun.jl:147</code></p><p>might be due to a wrong choice in the analysis parameters, for example a too long  correlation length.</p><footer><hr/></footer></article></body></html>
